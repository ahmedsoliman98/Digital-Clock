
Digital Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000145e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000008a  00800060  0000145e  000014f2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000b  008000ea  008000ea  0000157c  2**0
                  ALLOC
  3 .stab         000008d0  00000000  00000000  0000157c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000014d  00000000  00000000  00001e4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00001fa0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001f72  00000000  00000000  00002140  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000949  00000000  00000000  000040b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f52  00000000  00000000  000049fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000480  00000000  00000000  00005950  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000997  00000000  00000000  00005dd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000126d  00000000  00000000  00006767  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000010  00000000  00000000  000079d4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 b8 00 	jmp	0x170	; 0x170 <__vector_1>
       8:	0c 94 e1 00 	jmp	0x1c2	; 0x1c2 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 d5 09 	jmp	0x13aa	; 0x13aa <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 c6 09 	jmp	0x138c	; 0x138c <__vector_10>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e5       	ldi	r30, 0x5E	; 94
      68:	f4 e1       	ldi	r31, 0x14	; 20
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 3e       	cpi	r26, 0xEA	; 234
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	aa ee       	ldi	r26, 0xEA	; 234
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 3f       	cpi	r26, 0xF5	; 245
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e6 09 	call	0x13cc	; 0x13cc <main>
      8a:	0c 94 2d 0a 	jmp	0x145a	; 0x145a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_pinConfiguration>:




void DIO_pinConfiguration(GPIO * pinC, pinNumber pin_num, pinMode pin_M)
{
      92:	fc 01       	movw	r30, r24
	switch (pin_M)
      94:	41 30       	cpi	r20, 0x01	; 1
      96:	19 f1       	breq	.+70     	; 0xde <DIO_pinConfiguration+0x4c>
      98:	41 30       	cpi	r20, 0x01	; 1
      9a:	78 f4       	brcc	.+30     	; 0xba <DIO_pinConfiguration+0x28>
		RESET_Bit(pinC -> DDR, pin_num);
		SET_Bit(pinC -> PORT, pin_num);
		break;
		case InputFloat:
		/* In This Case We Make The Pin Input By Get Low in The DDR And Make It Default State (idle) LOW By RESET The Port And Make A Pull down Resistance  */
		RESET_Bit(pinC -> DDR,pin_num);
      9c:	21 81       	ldd	r18, Z+1	; 0x01
      9e:	81 e0       	ldi	r24, 0x01	; 1
      a0:	90 e0       	ldi	r25, 0x00	; 0
      a2:	02 c0       	rjmp	.+4      	; 0xa8 <DIO_pinConfiguration+0x16>
      a4:	88 0f       	add	r24, r24
      a6:	99 1f       	adc	r25, r25
      a8:	6a 95       	dec	r22
      aa:	e2 f7       	brpl	.-8      	; 0xa4 <DIO_pinConfiguration+0x12>
      ac:	80 95       	com	r24
      ae:	28 23       	and	r18, r24
      b0:	21 83       	std	Z+1, r18	; 0x01
		RESET_Bit(pinC -> PORT,pin_num);
      b2:	92 81       	ldd	r25, Z+2	; 0x02
      b4:	98 23       	and	r25, r24
      b6:	92 83       	std	Z+2, r25	; 0x02
		break;
      b8:	08 95       	ret



void DIO_pinConfiguration(GPIO * pinC, pinNumber pin_num, pinMode pin_M)
{
	switch (pin_M)
      ba:	42 30       	cpi	r20, 0x02	; 2
      bc:	09 f0       	breq	.+2      	; 0xc0 <DIO_pinConfiguration+0x2e>
      be:	08 95       	ret
		RESET_Bit(pinC -> DDR,pin_num);
		RESET_Bit(pinC -> PORT,pin_num);
		break;
		case Output:
		/* In This Case We Make The Pin Output By  SET The DDR And Make It Default State (idle) LOW By Set The Port TO Make It reverse Connection Sink Source to Avoid Error Value When The Number Of The Output Increace */
		SET_Bit(pinC -> DDR, pin_num);
      c0:	21 81       	ldd	r18, Z+1	; 0x01
      c2:	81 e0       	ldi	r24, 0x01	; 1
      c4:	90 e0       	ldi	r25, 0x00	; 0
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_pinConfiguration+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	6a 95       	dec	r22
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_pinConfiguration+0x36>
      d0:	28 2b       	or	r18, r24
      d2:	21 83       	std	Z+1, r18	; 0x01
		RESET_Bit(pinC -> PORT,pin_num);
      d4:	92 81       	ldd	r25, Z+2	; 0x02
      d6:	80 95       	com	r24
      d8:	89 23       	and	r24, r25
      da:	82 83       	std	Z+2, r24	; 0x02
      dc:	08 95       	ret
{
	switch (pin_M)
	{
		case InputPullup:
		/* In This Case We Make The Pin Input By Get Low in The DDR And Make It Default State (idle) HIgh By Set The Port */
		RESET_Bit(pinC -> DDR, pin_num);
      de:	21 81       	ldd	r18, Z+1	; 0x01
      e0:	81 e0       	ldi	r24, 0x01	; 1
      e2:	90 e0       	ldi	r25, 0x00	; 0
      e4:	02 c0       	rjmp	.+4      	; 0xea <DIO_pinConfiguration+0x58>
      e6:	88 0f       	add	r24, r24
      e8:	99 1f       	adc	r25, r25
      ea:	6a 95       	dec	r22
      ec:	e2 f7       	brpl	.-8      	; 0xe6 <DIO_pinConfiguration+0x54>
      ee:	98 2f       	mov	r25, r24
      f0:	90 95       	com	r25
      f2:	92 23       	and	r25, r18
      f4:	91 83       	std	Z+1, r25	; 0x01
		SET_Bit(pinC -> PORT, pin_num);
      f6:	92 81       	ldd	r25, Z+2	; 0x02
      f8:	98 2b       	or	r25, r24
      fa:	92 83       	std	Z+2, r25	; 0x02
		break;
      fc:	08 95       	ret

000000fe <DIO_pinWrite>:




 void DIO_pinWrite(GPIO * pinC, pinNumber pin_num, DigitalValue state)
 {
      fe:	fc 01       	movw	r30, r24
	 switch(state)
     100:	44 23       	and	r20, r20
     102:	61 f4       	brne	.+24     	; 0x11c <DIO_pinWrite+0x1e>
		 /* The Pin Get Output High State */
		 SET_Bit(pinC -> PORT, pin_num);
		 break;
		 case LOW:
		 /* The Pin Get Output Low State */
		 RESET_Bit(pinC -> PORT, pin_num);
     104:	22 81       	ldd	r18, Z+2	; 0x02
     106:	81 e0       	ldi	r24, 0x01	; 1
     108:	90 e0       	ldi	r25, 0x00	; 0
     10a:	02 c0       	rjmp	.+4      	; 0x110 <DIO_pinWrite+0x12>
     10c:	88 0f       	add	r24, r24
     10e:	99 1f       	adc	r25, r25
     110:	6a 95       	dec	r22
     112:	e2 f7       	brpl	.-8      	; 0x10c <DIO_pinWrite+0xe>
     114:	80 95       	com	r24
     116:	82 23       	and	r24, r18
     118:	82 83       	std	Z+2, r24	; 0x02
     11a:	08 95       	ret



 void DIO_pinWrite(GPIO * pinC, pinNumber pin_num, DigitalValue state)
 {
	 switch(state)
     11c:	41 30       	cpi	r20, 0x01	; 1
     11e:	e9 f7       	brne	.-6      	; 0x11a <DIO_pinWrite+0x1c>
	 {
		 case HIGH:
		 /* The Pin Get Output High State */
		 SET_Bit(pinC -> PORT, pin_num);
     120:	22 81       	ldd	r18, Z+2	; 0x02
     122:	81 e0       	ldi	r24, 0x01	; 1
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	02 c0       	rjmp	.+4      	; 0x12c <DIO_pinWrite+0x2e>
     128:	88 0f       	add	r24, r24
     12a:	99 1f       	adc	r25, r25
     12c:	6a 95       	dec	r22
     12e:	e2 f7       	brpl	.-8      	; 0x128 <DIO_pinWrite+0x2a>
     130:	28 2b       	or	r18, r24
     132:	22 83       	std	Z+2, r18	; 0x02
		 break;
     134:	08 95       	ret

00000136 <DIO_pinRead>:
 
 
 DigitalValue DIO_pinRead(GPIO * pinC, pinNumber pin_num)
 {
	 /* This Function Return The Current State Of The Pin by Use The READ_Bit Definition In The Macro Header */
	 return (READ_Bit(pinC -> PIN, pin_num));
     136:	fc 01       	movw	r30, r24
     138:	20 81       	ld	r18, Z
     13a:	81 e0       	ldi	r24, 0x01	; 1
     13c:	90 e0       	ldi	r25, 0x00	; 0
     13e:	06 2e       	mov	r0, r22
     140:	02 c0       	rjmp	.+4      	; 0x146 <DIO_pinRead+0x10>
     142:	88 0f       	add	r24, r24
     144:	99 1f       	adc	r25, r25
     146:	0a 94       	dec	r0
     148:	e2 f7       	brpl	.-8      	; 0x142 <DIO_pinRead+0xc>
     14a:	30 e0       	ldi	r19, 0x00	; 0
     14c:	82 23       	and	r24, r18
     14e:	93 23       	and	r25, r19
     150:	02 c0       	rjmp	.+4      	; 0x156 <DIO_pinRead+0x20>
     152:	95 95       	asr	r25
     154:	87 95       	ror	r24
     156:	6a 95       	dec	r22
     158:	e2 f7       	brpl	.-8      	; 0x152 <DIO_pinRead+0x1c>
 }
     15a:	08 95       	ret

0000015c <DIO_portConfiguration>:
	  
	  if (portValue <= MAX_uint8_VALUE && portValue >= MIN_uint8_VALUE)
	  {
		  /* The Value On The 8 bit DDR To Define Each Pin From The 8 Pins Of The Port As input Or Output */
		  /* equal the port to the 0xFF to get the output */
		  portC->DDR = portValue;
     15c:	fc 01       	movw	r30, r24
     15e:	61 83       	std	Z+1, r22	; 0x01
	  }
	  else
	  {
		  //DIO_ErrorIndication()
	  }
  } 
     160:	08 95       	ret

00000162 <DIO_portWrite>:
 {
	  /* We Must Check That THe Value Of The configuration Of The Port Does Not exceed The 8 bit (0 <-> 255) */
	 if (portValue <= MAX_uint8_VALUE && portValue >= MIN_uint8_VALUE)
	 {
		 /* Get Out The 8bit Value On The * Pins Of The Port */
		 portC->PORT = portValue;
     162:	fc 01       	movw	r30, r24
     164:	62 83       	std	Z+2, r22	; 0x02
	 }
	 else if (portValue < MIN_uint8_VALUE)
	 {
		 portC->PORT = 0x00;
	 }
 }
     166:	08 95       	ret

00000168 <DIO_portRead>:
 
 
 uint8 DIO_portRead(GPIO * portC)
 {
	 /* we And THe Value Of The Port With 1111 1111 And return the result To Get Port State */
	 return (READ_Bit(portC->PORT,ANDINGV_to_readPORT));
     168:	fc 01       	movw	r30, r24
     16a:	82 81       	ldd	r24, Z+2	; 0x02
	 
 }
     16c:	80 e0       	ldi	r24, 0x00	; 0
     16e:	08 95       	ret

00000170 <__vector_1>:
  
  
  

  ISR (INT0_vect,ISR_NESTED_ENABLE)
     {
     170:	1f 92       	push	r1
     172:	0f 92       	push	r0
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	0f 92       	push	r0
     178:	11 24       	eor	r1, r1
     17a:	2f 93       	push	r18
     17c:	3f 93       	push	r19
     17e:	4f 93       	push	r20
     180:	5f 93       	push	r21
     182:	6f 93       	push	r22
     184:	7f 93       	push	r23
     186:	8f 93       	push	r24
     188:	9f 93       	push	r25
     18a:	af 93       	push	r26
     18c:	bf 93       	push	r27
     18e:	ef 93       	push	r30
     190:	ff 93       	push	r31
		 if (EXTINT0_ISR != NULL)
     192:	e0 91 ee 00 	lds	r30, 0x00EE
     196:	f0 91 ef 00 	lds	r31, 0x00EF
     19a:	30 97       	sbiw	r30, 0x00	; 0
     19c:	09 f0       	breq	.+2      	; 0x1a0 <__vector_1+0x30>
		 {
			 EXTINT0_ISR();
     19e:	09 95       	icall
		 }
	 }
     1a0:	ff 91       	pop	r31
     1a2:	ef 91       	pop	r30
     1a4:	bf 91       	pop	r27
     1a6:	af 91       	pop	r26
     1a8:	9f 91       	pop	r25
     1aa:	8f 91       	pop	r24
     1ac:	7f 91       	pop	r23
     1ae:	6f 91       	pop	r22
     1b0:	5f 91       	pop	r21
     1b2:	4f 91       	pop	r20
     1b4:	3f 91       	pop	r19
     1b6:	2f 91       	pop	r18
     1b8:	0f 90       	pop	r0
     1ba:	0f be       	out	0x3f, r0	; 63
     1bc:	0f 90       	pop	r0
     1be:	1f 90       	pop	r1
     1c0:	18 95       	reti

000001c2 <__vector_2>:
	 
	ISR (INT1_vect,ISR_NESTED_ENABLE)
	{
     1c2:	1f 92       	push	r1
     1c4:	0f 92       	push	r0
     1c6:	0f b6       	in	r0, 0x3f	; 63
     1c8:	0f 92       	push	r0
     1ca:	11 24       	eor	r1, r1
     1cc:	2f 93       	push	r18
     1ce:	3f 93       	push	r19
     1d0:	4f 93       	push	r20
     1d2:	5f 93       	push	r21
     1d4:	6f 93       	push	r22
     1d6:	7f 93       	push	r23
     1d8:	8f 93       	push	r24
     1da:	9f 93       	push	r25
     1dc:	af 93       	push	r26
     1de:	bf 93       	push	r27
     1e0:	ef 93       	push	r30
     1e2:	ff 93       	push	r31
		if (EXTINT1_ISR != NULL)
     1e4:	e0 91 ec 00 	lds	r30, 0x00EC
     1e8:	f0 91 ed 00 	lds	r31, 0x00ED
     1ec:	30 97       	sbiw	r30, 0x00	; 0
     1ee:	09 f0       	breq	.+2      	; 0x1f2 <__vector_2+0x30>
		{
			EXTINT1_ISR();
     1f0:	09 95       	icall
		}
	}
     1f2:	ff 91       	pop	r31
     1f4:	ef 91       	pop	r30
     1f6:	bf 91       	pop	r27
     1f8:	af 91       	pop	r26
     1fa:	9f 91       	pop	r25
     1fc:	8f 91       	pop	r24
     1fe:	7f 91       	pop	r23
     200:	6f 91       	pop	r22
     202:	5f 91       	pop	r21
     204:	4f 91       	pop	r20
     206:	3f 91       	pop	r19
     208:	2f 91       	pop	r18
     20a:	0f 90       	pop	r0
     20c:	0f be       	out	0x3f, r0	; 63
     20e:	0f 90       	pop	r0
     210:	1f 90       	pop	r1
     212:	18 95       	reti

00000214 <EXTINT_InterruptInit>:



	void EXTINT_InterruptInit(EXInterrupt_Source source,ExInterrupt_Modes Mode)
	{
		switch (source)
     214:	81 30       	cpi	r24, 0x01	; 1
     216:	f9 f0       	breq	.+62     	; 0x256 <EXTINT_InterruptInit+0x42>
     218:	81 30       	cpi	r24, 0x01	; 1
     21a:	78 f4       	brcc	.+30     	; 0x23a <EXTINT_InterruptInit+0x26>
		{
			case EXINT_INT0 :
				 switch (Mode)
     21c:	61 30       	cpi	r22, 0x01	; 1
     21e:	a1 f1       	breq	.+104    	; 0x288 <EXTINT_InterruptInit+0x74>
     220:	61 30       	cpi	r22, 0x01	; 1
     222:	08 f0       	brcs	.+2      	; 0x226 <EXTINT_InterruptInit+0x12>
     224:	43 c0       	rjmp	.+134    	; 0x2ac <EXTINT_InterruptInit+0x98>
				 {
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC00);
     226:	85 b7       	in	r24, 0x35	; 53
     228:	8e 7f       	andi	r24, 0xFE	; 254
     22a:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC01);
     22c:	85 b7       	in	r24, 0x35	; 53
     22e:	8d 7f       	andi	r24, 0xFD	; 253
     230:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC00);
						  SET_Bit(MCUCR,ISC01);
						  break;
				  }
				/* Enable THe InT 0 */
				SET_Bit(GICR,INT0);	
     232:	8b b7       	in	r24, 0x3b	; 59
     234:	80 64       	ori	r24, 0x40	; 64
     236:	8b bf       	out	0x3b, r24	; 59
				break;
     238:	08 95       	ret



	void EXTINT_InterruptInit(EXInterrupt_Source source,ExInterrupt_Modes Mode)
	{
		switch (source)
     23a:	82 30       	cpi	r24, 0x02	; 2
     23c:	09 f0       	breq	.+2      	; 0x240 <EXTINT_InterruptInit+0x2c>
     23e:	08 95       	ret
				 }
				 /* Enable THe InT 0 */
				 SET_Bit(GICR,INT1);
				 break;
		  case EXINT_INT2 :
			   switch (Mode)
     240:	62 30       	cpi	r22, 0x02	; 2
     242:	b9 f0       	breq	.+46     	; 0x272 <EXTINT_InterruptInit+0x5e>
     244:	63 30       	cpi	r22, 0x03	; 3
     246:	19 f4       	brne	.+6      	; 0x24e <EXTINT_InterruptInit+0x3a>
			   {
				   case EXINT_FallingEdge :
						RESET_Bit(MCUCSR,ISC2);
						break;
				   case EXINT_RisingEdge :
						SET_Bit(MCUCSR,ISC2);
     248:	84 b7       	in	r24, 0x34	; 52
     24a:	80 64       	ori	r24, 0x40	; 64
     24c:	84 bf       	out	0x34, r24	; 52
				  case EXINT_LowLevel :
				  case EXINT_Toggle :
				  break;
			   }
			   /* Enable THe InT 0 */
			   SET_Bit(GICR,INT2);
     24e:	8b b7       	in	r24, 0x3b	; 59
     250:	80 62       	ori	r24, 0x20	; 32
     252:	8b bf       	out	0x3b, r24	; 59
     254:	08 95       	ret
				  }
				/* Enable THe InT 0 */
				SET_Bit(GICR,INT0);	
				break;
		  case EXINT_INT1 :
				 switch (Mode)
     256:	61 30       	cpi	r22, 0x01	; 1
     258:	81 f0       	breq	.+32     	; 0x27a <EXTINT_InterruptInit+0x66>
     25a:	61 30       	cpi	r22, 0x01	; 1
     25c:	e0 f4       	brcc	.+56     	; 0x296 <EXTINT_InterruptInit+0x82>
				 {
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC10);
     25e:	85 b7       	in	r24, 0x35	; 53
     260:	8b 7f       	andi	r24, 0xFB	; 251
     262:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC11);
     264:	85 b7       	in	r24, 0x35	; 53
     266:	87 7f       	andi	r24, 0xF7	; 247
     268:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC11);
						  SET_Bit(MCUCR,ISC10);
					break;
				 }
				 /* Enable THe InT 0 */
				 SET_Bit(GICR,INT1);
     26a:	8b b7       	in	r24, 0x3b	; 59
     26c:	80 68       	ori	r24, 0x80	; 128
     26e:	8b bf       	out	0x3b, r24	; 59
				 break;
     270:	08 95       	ret
		  case EXINT_INT2 :
			   switch (Mode)
			   {
				   case EXINT_FallingEdge :
						RESET_Bit(MCUCSR,ISC2);
     272:	84 b7       	in	r24, 0x34	; 52
     274:	8f 7b       	andi	r24, 0xBF	; 191
     276:	84 bf       	out	0x34, r24	; 52
						break;
     278:	ea cf       	rjmp	.-44     	; 0x24e <EXTINT_InterruptInit+0x3a>
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC10);
						  RESET_Bit(MCUCR,ISC11);
						  break;
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC11);
     27a:	85 b7       	in	r24, 0x35	; 53
     27c:	88 60       	ori	r24, 0x08	; 8
     27e:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC10);
     280:	85 b7       	in	r24, 0x35	; 53
     282:	8b 7f       	andi	r24, 0xFB	; 251
     284:	85 bf       	out	0x35, r24	; 53
						  break;
     286:	f1 cf       	rjmp	.-30     	; 0x26a <EXTINT_InterruptInit+0x56>
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC00);
						  RESET_Bit(MCUCR,ISC01);
						  break;
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC00);
     288:	85 b7       	in	r24, 0x35	; 53
     28a:	81 60       	ori	r24, 0x01	; 1
     28c:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC01);
     28e:	85 b7       	in	r24, 0x35	; 53
     290:	8d 7f       	andi	r24, 0xFD	; 253
     292:	85 bf       	out	0x35, r24	; 53
						  break;
     294:	ce cf       	rjmp	.-100    	; 0x232 <EXTINT_InterruptInit+0x1e>
				  }
				/* Enable THe InT 0 */
				SET_Bit(GICR,INT0);	
				break;
		  case EXINT_INT1 :
				 switch (Mode)
     296:	62 30       	cpi	r22, 0x02	; 2
     298:	e1 f0       	breq	.+56     	; 0x2d2 <EXTINT_InterruptInit+0xbe>
     29a:	63 30       	cpi	r22, 0x03	; 3
     29c:	31 f7       	brne	.-52     	; 0x26a <EXTINT_InterruptInit+0x56>
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC11);
						  SET_Bit(MCUCR,ISC10);
						  break;
					 case EXINT_RisingEdge :
						  SET_Bit(MCUCR,ISC11);
     29e:	85 b7       	in	r24, 0x35	; 53
     2a0:	88 60       	ori	r24, 0x08	; 8
     2a2:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC10);
     2a4:	85 b7       	in	r24, 0x35	; 53
     2a6:	84 60       	ori	r24, 0x04	; 4
     2a8:	85 bf       	out	0x35, r24	; 53
					break;
     2aa:	df cf       	rjmp	.-66     	; 0x26a <EXTINT_InterruptInit+0x56>
	void EXTINT_InterruptInit(EXInterrupt_Source source,ExInterrupt_Modes Mode)
	{
		switch (source)
		{
			case EXINT_INT0 :
				 switch (Mode)
     2ac:	62 30       	cpi	r22, 0x02	; 2
     2ae:	51 f0       	breq	.+20     	; 0x2c4 <EXTINT_InterruptInit+0xb0>
     2b0:	63 30       	cpi	r22, 0x03	; 3
     2b2:	09 f0       	breq	.+2      	; 0x2b6 <EXTINT_InterruptInit+0xa2>
     2b4:	be cf       	rjmp	.-132    	; 0x232 <EXTINT_InterruptInit+0x1e>
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC00);
						  SET_Bit(MCUCR,ISC01);
						  break;
					 case EXINT_RisingEdge :
						  SET_Bit(MCUCR,ISC00);
     2b6:	85 b7       	in	r24, 0x35	; 53
     2b8:	81 60       	ori	r24, 0x01	; 1
     2ba:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC01);
     2bc:	85 b7       	in	r24, 0x35	; 53
     2be:	82 60       	ori	r24, 0x02	; 2
     2c0:	85 bf       	out	0x35, r24	; 53
						  break;
     2c2:	b7 cf       	rjmp	.-146    	; 0x232 <EXTINT_InterruptInit+0x1e>
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC00);
						  RESET_Bit(MCUCR,ISC01);
						  break;
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC00);
     2c4:	85 b7       	in	r24, 0x35	; 53
     2c6:	8e 7f       	andi	r24, 0xFE	; 254
     2c8:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC01);
     2ca:	85 b7       	in	r24, 0x35	; 53
     2cc:	82 60       	ori	r24, 0x02	; 2
     2ce:	85 bf       	out	0x35, r24	; 53
						  break;
     2d0:	b0 cf       	rjmp	.-160    	; 0x232 <EXTINT_InterruptInit+0x1e>
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC11);
						  RESET_Bit(MCUCR,ISC10);
						  break;
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC11);
     2d2:	85 b7       	in	r24, 0x35	; 53
     2d4:	87 7f       	andi	r24, 0xF7	; 247
     2d6:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC10);
     2d8:	85 b7       	in	r24, 0x35	; 53
     2da:	84 60       	ori	r24, 0x04	; 4
     2dc:	85 bf       	out	0x35, r24	; 53
						  break;
     2de:	c5 cf       	rjmp	.-118    	; 0x26a <EXTINT_InterruptInit+0x56>

000002e0 <TIMER_INTIATE>:
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
		unsigned char TIMASK_Temp = 0x00;
		
		/* Set up the Timer The User Select */
		switch(T.timer_Number)
     2e0:	66 23       	and	r22, r22
     2e2:	e9 f4       	brne	.+58     	; 0x31e <TIMER_INTIATE+0x3e>
     2e4:	71 50       	subi	r23, 0x01	; 1
     2e6:	74 30       	cpi	r23, 0x04	; 4
     2e8:	80 f1       	brcs	.+96     	; 0x34a <TIMER_INTIATE+0x6a>
     2ea:	20 e0       	ldi	r18, 0x00	; 0
					default:
					break;
				}
		
				/* Set Up The Timer Clock Frequency By The Bit CS00, CS01 , CS02 In The TCCR */
				switch(T.timer_CLK)
     2ec:	87 30       	cpi	r24, 0x07	; 7
     2ee:	09 f4       	brne	.+2      	; 0x2f2 <TIMER_INTIATE+0x12>
     2f0:	7d c0       	rjmp	.+250    	; 0x3ec <TIMER_INTIATE+0x10c>
     2f2:	88 30       	cpi	r24, 0x08	; 8
     2f4:	08 f0       	brcs	.+2      	; 0x2f8 <TIMER_INTIATE+0x18>
     2f6:	4d c0       	rjmp	.+154    	; 0x392 <TIMER_INTIATE+0xb2>
     2f8:	83 30       	cpi	r24, 0x03	; 3
     2fa:	09 f4       	brne	.+2      	; 0x2fe <TIMER_INTIATE+0x1e>
     2fc:	71 c0       	rjmp	.+226    	; 0x3e0 <TIMER_INTIATE+0x100>
     2fe:	84 30       	cpi	r24, 0x04	; 4
     300:	09 f4       	brne	.+2      	; 0x304 <TIMER_INTIATE+0x24>
     302:	6b c0       	rjmp	.+214    	; 0x3da <TIMER_INTIATE+0xfa>
     304:	81 30       	cpi	r24, 0x01	; 1
     306:	09 f4       	brne	.+2      	; 0x30a <TIMER_INTIATE+0x2a>
     308:	60 c0       	rjmp	.+192    	; 0x3ca <TIMER_INTIATE+0xea>
				   default:
				   break;
				}
		
				/* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
				switch(T.TimerINT_Source)
     30a:	91 30       	cpi	r25, 0x01	; 1
     30c:	09 f4       	brne	.+2      	; 0x310 <TIMER_INTIATE+0x30>
     30e:	4a c0       	rjmp	.+148    	; 0x3a4 <TIMER_INTIATE+0xc4>
     310:	92 30       	cpi	r25, 0x02	; 2
     312:	39 f1       	breq	.+78     	; 0x362 <TIMER_INTIATE+0x82>
					break;
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
     314:	23 bf       	out	0x33, r18	; 51
			 break;
		}
			
		
		/* Set The I Bit In The Statues Register To Enable The General Interrupt */
		SET_Bit(SREG, 7);
     316:	8f b7       	in	r24, 0x3f	; 63
     318:	80 68       	ori	r24, 0x80	; 128
     31a:	8f bf       	out	0x3f, r24	; 63
	}					 
     31c:	08 95       	ret
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
		unsigned char TIMASK_Temp = 0x00;
		
		/* Set up the Timer The User Select */
		switch(T.timer_Number)
     31e:	61 30       	cpi	r22, 0x01	; 1
     320:	d1 f7       	brne	.-12     	; 0x316 <TIMER_INTIATE+0x36>
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
		break;
     322:	71 50       	subi	r23, 0x01	; 1
     324:	74 30       	cpi	r23, 0x04	; 4
     326:	b8 f0       	brcs	.+46     	; 0x356 <TIMER_INTIATE+0x76>
     328:	20 e0       	ldi	r18, 0x00	; 0
			     default:
			     break;
		     }
		     
		     /* Set Up The Timer Clock Frequency By The Bit CS20, CS21 , CS22 In The TCCR2 */
		     switch(T.timer_CLK)
     32a:	84 30       	cpi	r24, 0x04	; 4
     32c:	09 f4       	brne	.+2      	; 0x330 <TIMER_INTIATE+0x50>
     32e:	64 c0       	rjmp	.+200    	; 0x3f8 <TIMER_INTIATE+0x118>
     330:	85 30       	cpi	r24, 0x05	; 5
     332:	e0 f4       	brcc	.+56     	; 0x36c <TIMER_INTIATE+0x8c>
     334:	82 30       	cpi	r24, 0x02	; 2
     336:	09 f4       	brne	.+2      	; 0x33a <TIMER_INTIATE+0x5a>
     338:	65 c0       	rjmp	.+202    	; 0x404 <TIMER_INTIATE+0x124>
     33a:	83 30       	cpi	r24, 0x03	; 3
     33c:	08 f0       	brcs	.+2      	; 0x340 <TIMER_INTIATE+0x60>
     33e:	42 c0       	rjmp	.+132    	; 0x3c4 <TIMER_INTIATE+0xe4>
     340:	81 30       	cpi	r24, 0x01	; 1
     342:	f1 f4       	brne	.+60     	; 0x380 <TIMER_INTIATE+0xa0>
		     {
			     case Timer_NoCLK_Source:
			     /* It SI The Default State At All Bit Equal 0 */
			     break;
			     case Timer_Fcpu:
			     SET_Bit(TCCR_Temp,CS20);
     344:	21 60       	ori	r18, 0x01	; 1
			     RESET_Bit(TCCR_Temp,CS21);
			     RESET_Bit(TCCR_Temp,CS22);
     346:	29 7f       	andi	r18, 0xF9	; 249
			     break;
     348:	1b c0       	rjmp	.+54     	; 0x380 <TIMER_INTIATE+0xa0>
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
		unsigned char TIMASK_Temp = 0x00;
		
		/* Set up the Timer The User Select */
		switch(T.timer_Number)
     34a:	e7 2f       	mov	r30, r23
     34c:	f0 e0       	ldi	r31, 0x00	; 0
     34e:	e0 5a       	subi	r30, 0xA0	; 160
     350:	ff 4f       	sbci	r31, 0xFF	; 255
     352:	20 81       	ld	r18, Z
     354:	cb cf       	rjmp	.-106    	; 0x2ec <TIMER_INTIATE+0xc>
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
		break;
     356:	e7 2f       	mov	r30, r23
     358:	f0 e0       	ldi	r31, 0x00	; 0
     35a:	ec 59       	subi	r30, 0x9C	; 156
     35c:	ff 4f       	sbci	r31, 0xFF	; 255
     35e:	20 81       	ld	r18, Z
     360:	e4 cf       	rjmp	.-56     	; 0x32a <TIMER_INTIATE+0x4a>
						 /* This Interrupt happened when the TCNT reach its Max then return to zero again */ 
						 SET_Bit(TIMSK,TOIE0);
					break;
					case Timer_TopCTC_Interrupt:
						 /* This Interrupt happened When The TCNT Reach The Value Equal The Value OnThe OCR and Return To Zero */
						 SET_Bit(TIMSK,OCIE0);
     362:	89 b7       	in	r24, 0x39	; 57
     364:	82 60       	ori	r24, 0x02	; 2
     366:	89 bf       	out	0x39, r24	; 57
					break;
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
     368:	23 bf       	out	0x33, r18	; 51
     36a:	d5 cf       	rjmp	.-86     	; 0x316 <TIMER_INTIATE+0x36>
			     default:
			     break;
		     }
		     
		     /* Set Up The Timer Clock Frequency By The Bit CS20, CS21 , CS22 In The TCCR2 */
		     switch(T.timer_CLK)
     36c:	86 30       	cpi	r24, 0x06	; 6
     36e:	09 f4       	brne	.+2      	; 0x372 <TIMER_INTIATE+0x92>
     370:	46 c0       	rjmp	.+140    	; 0x3fe <TIMER_INTIATE+0x11e>
     372:	86 30       	cpi	r24, 0x06	; 6
     374:	20 f1       	brcs	.+72     	; 0x3be <TIMER_INTIATE+0xde>
     376:	87 30       	cpi	r24, 0x07	; 7
     378:	e1 f1       	breq	.+120    	; 0x3f2 <TIMER_INTIATE+0x112>
     37a:	88 30       	cpi	r24, 0x08	; 8
     37c:	09 f4       	brne	.+2      	; 0x380 <TIMER_INTIATE+0xa0>
			     SET_Bit(TCCR_Temp,CS22);
			     break;
			     case Timer_Fcpu_Div1024:
			     SET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
     37e:	27 60       	ori	r18, 0x07	; 7
				 /* If The User Select Else This Cases Handle An Error Massage */
			     break;
		     }
		     
		     /* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
		     switch(T.TimerINT_Source)
     380:	91 30       	cpi	r25, 0x01	; 1
     382:	31 f1       	breq	.+76     	; 0x3d0 <TIMER_INTIATE+0xf0>
     384:	92 30       	cpi	r25, 0x02	; 2
     386:	99 f0       	breq	.+38     	; 0x3ae <TIMER_INTIATE+0xce>
			     break;
			     default:
			     break;
			     
		     }
			 TCCR2 = TCCR_Temp;
     388:	25 bd       	out	0x25, r18	; 37
			 break;
		}
			
		
		/* Set The I Bit In The Statues Register To Enable The General Interrupt */
		SET_Bit(SREG, 7);
     38a:	8f b7       	in	r24, 0x3f	; 63
     38c:	80 68       	ori	r24, 0x80	; 128
     38e:	8f bf       	out	0x3f, r24	; 63
	}					 
     390:	08 95       	ret
					default:
					break;
				}
		
				/* Set Up The Timer Clock Frequency By The Bit CS00, CS01 , CS02 In The TCCR */
				switch(T.timer_CLK)
     392:	89 30       	cpi	r24, 0x09	; 9
     394:	41 f1       	breq	.+80     	; 0x3e6 <TIMER_INTIATE+0x106>
     396:	89 30       	cpi	r24, 0x09	; 9
     398:	78 f0       	brcs	.+30     	; 0x3b8 <TIMER_INTIATE+0xd8>
     39a:	8a 30       	cpi	r24, 0x0A	; 10
     39c:	09 f0       	breq	.+2      	; 0x3a0 <TIMER_INTIATE+0xc0>
     39e:	b5 cf       	rjmp	.-150    	; 0x30a <TIMER_INTIATE+0x2a>
						 SET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_RisingEdge:
						 SET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
     3a0:	27 60       	ori	r18, 0x07	; 7
				   break;
     3a2:	b3 cf       	rjmp	.-154    	; 0x30a <TIMER_INTIATE+0x2a>
				/* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
				switch(T.TimerINT_Source)
				{
					case Timer_Overflow_Interrupt:
						 /* This Interrupt happened when the TCNT reach its Max then return to zero again */ 
						 SET_Bit(TIMSK,TOIE0);
     3a4:	89 b7       	in	r24, 0x39	; 57
     3a6:	81 60       	ori	r24, 0x01	; 1
     3a8:	89 bf       	out	0x39, r24	; 57
					break;
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
     3aa:	23 bf       	out	0x33, r18	; 51
     3ac:	b4 cf       	rjmp	.-152    	; 0x316 <TIMER_INTIATE+0x36>
			     /* This Interrupt happened when the TCNT reach its Max then return to zero again */
			     SET_Bit(TIMSK,TOIE2);
			     break;
			     case Timer_TopCTC_Interrupt:
			     /* This Interrupt happened When The TCNT Reach The Value Equal The Value OnThe OCR and Return To Zero */
			     SET_Bit(TIMSK,OCIE2);
     3ae:	89 b7       	in	r24, 0x39	; 57
     3b0:	80 68       	ori	r24, 0x80	; 128
     3b2:	89 bf       	out	0x39, r24	; 57
			     break;
			     default:
			     break;
			     
		     }
			 TCCR2 = TCCR_Temp;
     3b4:	25 bd       	out	0x25, r18	; 37
     3b6:	e9 cf       	rjmp	.-46     	; 0x38a <TIMER_INTIATE+0xaa>
						 RESET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_Fcpu_Div1024:
						 SET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
     3b8:	28 7f       	andi	r18, 0xF8	; 248
						 SET_Bit(TCCR_Temp,CS02);
     3ba:	25 60       	ori	r18, 0x05	; 5
					break;
     3bc:	a6 cf       	rjmp	.-180    	; 0x30a <TIMER_INTIATE+0x2a>
			     SET_Bit(TCCR_Temp,CS21);
			     RESET_Bit(TCCR_Temp,CS22);
			     break;
			     case Timer_Fcpu_Div32:
			     SET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
     3be:	23 60       	ori	r18, 0x03	; 3
			     RESET_Bit(TCCR_Temp,CS22);
     3c0:	2b 7f       	andi	r18, 0xFB	; 251
			     break;
     3c2:	de cf       	rjmp	.-68     	; 0x380 <TIMER_INTIATE+0xa0>
					  RESET_Bit(TCCR_Temp,CS21);
					  SET_Bit(TCCR_Temp,CS22);
				 break;
			     case Timer_Fcpu_Div8:
			     RESET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
     3c4:	28 7f       	andi	r18, 0xF8	; 248
			     RESET_Bit(TCCR_Temp,CS22);
     3c6:	22 60       	ori	r18, 0x02	; 2
			     break;
     3c8:	db cf       	rjmp	.-74     	; 0x380 <TIMER_INTIATE+0xa0>
					case Timer_NoCLK_Source:
						/* It SI The Default State At All Bit Equal 0 */
						/* In This Case The Timer Gets Its Clock From External Device */
					break;
					case Timer_Fcpu:
						 SET_Bit(TCCR_Temp,CS00);
     3ca:	21 60       	ori	r18, 0x01	; 1
						 RESET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
     3cc:	29 7f       	andi	r18, 0xF9	; 249
					break;
     3ce:	9d cf       	rjmp	.-198    	; 0x30a <TIMER_INTIATE+0x2a>
		     /* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
		     switch(T.TimerINT_Source)
		     {
			     case Timer_Overflow_Interrupt:
			     /* This Interrupt happened when the TCNT reach its Max then return to zero again */
			     SET_Bit(TIMSK,TOIE2);
     3d0:	89 b7       	in	r24, 0x39	; 57
     3d2:	80 64       	ori	r24, 0x40	; 64
     3d4:	89 bf       	out	0x39, r24	; 57
			     break;
			     default:
			     break;
			     
		     }
			 TCCR2 = TCCR_Temp;
     3d6:	25 bd       	out	0x25, r18	; 37
     3d8:	d8 cf       	rjmp	.-80     	; 0x38a <TIMER_INTIATE+0xaa>
						 SET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_Fcpu_Div64:
						 SET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
     3da:	23 60       	ori	r18, 0x03	; 3
						 RESET_Bit(TCCR_Temp,CS02);
     3dc:	2b 7f       	andi	r18, 0xFB	; 251
					break;
     3de:	95 cf       	rjmp	.-214    	; 0x30a <TIMER_INTIATE+0x2a>
						 RESET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_Fcpu_Div8:
						 RESET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
     3e0:	28 7f       	andi	r18, 0xF8	; 248
						 RESET_Bit(TCCR_Temp,CS02);
     3e2:	22 60       	ori	r18, 0x02	; 2
					break;
     3e4:	92 cf       	rjmp	.-220    	; 0x30a <TIMER_INTIATE+0x2a>
						 SET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_FallingEdge:
						 RESET_Bit(TCCR_Temp,CS00);
     3e6:	2e 7f       	andi	r18, 0xFE	; 254
						 SET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
     3e8:	26 60       	ori	r18, 0x06	; 6
					break;
     3ea:	8f cf       	rjmp	.-226    	; 0x30a <TIMER_INTIATE+0x2a>
						 SET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
					break;
					case Timer_Fcpu_Div256:
						 RESET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
     3ec:	2c 7f       	andi	r18, 0xFC	; 252
						 SET_Bit(TCCR_Temp,CS02);
     3ee:	24 60       	ori	r18, 0x04	; 4
					break;
     3f0:	8c cf       	rjmp	.-232    	; 0x30a <TIMER_INTIATE+0x2a>
			     SET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
			     break;
			     case Timer_Fcpu_Div256:
			     RESET_Bit(TCCR_Temp,CS20);
     3f2:	2e 7f       	andi	r18, 0xFE	; 254
			     SET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
     3f4:	26 60       	ori	r18, 0x06	; 6
			     break;
     3f6:	c4 cf       	rjmp	.-120    	; 0x380 <TIMER_INTIATE+0xa0>
			     SET_Bit(TCCR_Temp,CS21);
			     RESET_Bit(TCCR_Temp,CS22);
			     break;
			     case Timer_Fcpu_Div64:
			     RESET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
     3f8:	2c 7f       	andi	r18, 0xFC	; 252
			     SET_Bit(TCCR_Temp,CS22);
     3fa:	24 60       	ori	r18, 0x04	; 4
			     break;
     3fc:	c1 cf       	rjmp	.-126    	; 0x380 <TIMER_INTIATE+0xa0>
			     case Timer_Fcpu_Div128:
			     SET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
     3fe:	28 7f       	andi	r18, 0xF8	; 248
			     SET_Bit(TCCR_Temp,CS22);
     400:	25 60       	ori	r18, 0x05	; 5
			     break;
     402:	be cf       	rjmp	.-132    	; 0x380 <TIMER_INTIATE+0xa0>
				 case Timer2_OneSec_CLK:
				      /* In This Case To Get The Clock Exactly At One Sec We Used An External Clock With Value 32768Hz At Timer 2 Only Connect To the Pin 6 & 7 at Port C 
					   * Set the Pin AS2 At The Register ASSR To Make The Clock Source From The External Crystal 
					   *  Prescaler Value Will Used is 128 So 
					   */
					  ASSR = 0x08;
     404:	88 e0       	ldi	r24, 0x08	; 8
     406:	82 bd       	out	0x22, r24	; 34
					  SET_Bit(TCCR_Temp,CS20);
					  RESET_Bit(TCCR_Temp,CS21);
     408:	28 7f       	andi	r18, 0xF8	; 248
					  SET_Bit(TCCR_Temp,CS22);
     40a:	25 60       	ori	r18, 0x05	; 5
				 break;
     40c:	b9 cf       	rjmp	.-142    	; 0x380 <TIMER_INTIATE+0xa0>

0000040e <TIMER_DELAY>:

	
		
    void TIMER_DELAY(TIMER_DATATYPE t, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     40e:	66 23       	and	r22, r22
     410:	11 f4       	brne	.+4      	; 0x416 <TIMER_DELAY+0x8>
		{
			case Timer0: 
			     OCR0 = Top_Value;
     412:	4c bf       	out	0x3c, r20	; 60
			break;
     414:	08 95       	ret

	
		
    void TIMER_DELAY(TIMER_DATATYPE t, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     416:	61 30       	cpi	r22, 0x01	; 1
     418:	09 f0       	breq	.+2      	; 0x41c <TIMER_DELAY+0xe>
     41a:	08 95       	ret
		{
			case Timer0: 
			     OCR0 = Top_Value;
			break;
			case Timer2:
			     OCR2 = Top_Value;
     41c:	43 bd       	out	0x23, r20	; 35
     41e:	08 95       	ret

00000420 <TIMER_WAVEGEN_NPWM>:
		}
	}
	
	
	void TIMER_WAVEGEN_NPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     420:	cf 93       	push	r28
     422:	c4 2f       	mov	r28, r20
		switch (t.timer_Number)
     424:	66 23       	and	r22, r22
     426:	79 f4       	brne	.+30     	; 0x446 <TIMER_WAVEGEN_NPWM+0x26>
		{
			case Timer0 :
				/* Set The Value Of OCR0 That will Wave Change after it */
				OCR0 = Top_Value;
     428:	2c bf       	out	0x3c, r18	; 60
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     42a:	86 e3       	ldi	r24, 0x36	; 54
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	63 e0       	ldi	r22, 0x03	; 3
     430:	42 e0       	ldi	r20, 0x02	; 2
     432:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
				/* Switch on the form we want the signal get out after each compare match */
				switch(wave)
     436:	c2 30       	cpi	r28, 0x02	; 2
     438:	e1 f0       	breq	.+56     	; 0x472 <TIMER_WAVEGEN_NPWM+0x52>
     43a:	c3 30       	cpi	r28, 0x03	; 3
     43c:	41 f1       	breq	.+80     	; 0x48e <TIMER_WAVEGEN_NPWM+0x6e>
     43e:	c1 30       	cpi	r28, 0x01	; 1
     440:	69 f1       	breq	.+90     	; 0x49c <TIMER_WAVEGEN_NPWM+0x7c>
			break;
			default:
			break;
		}
	
	}	
     442:	cf 91       	pop	r28
     444:	08 95       	ret
	}
	
	
	void TIMER_WAVEGEN_NPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
		switch (t.timer_Number)
     446:	61 30       	cpi	r22, 0x01	; 1
     448:	e1 f7       	brne	.-8      	; 0x442 <TIMER_WAVEGEN_NPWM+0x22>
					break;
				}
			break;
			case Timer2: 
				    /* Set The Value Of OCR2 That will Wave Change after it */
					OCR2 = Top_Value;
     44a:	23 bd       	out	0x23, r18	; 35
					/* at the first we set up the pin of the wave output in the Mc as output state OC2 pin */
					DIO_pinConfiguration(GPIOD,PIN7, Output);
     44c:	80 e3       	ldi	r24, 0x30	; 48
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	67 e0       	ldi	r22, 0x07	; 7
     452:	42 e0       	ldi	r20, 0x02	; 2
     454:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
					/* Switch on the form we want the signal get out after each compare match */
					switch(wave)
     458:	c2 30       	cpi	r28, 0x02	; 2
     45a:	39 f1       	breq	.+78     	; 0x4aa <TIMER_WAVEGEN_NPWM+0x8a>
     45c:	c3 30       	cpi	r28, 0x03	; 3
     45e:	81 f0       	breq	.+32     	; 0x480 <TIMER_WAVEGEN_NPWM+0x60>
     460:	c1 30       	cpi	r28, 0x01	; 1
     462:	79 f7       	brne	.-34     	; 0x442 <TIMER_WAVEGEN_NPWM+0x22>
					{
						case NON:
						/* This is The Normal State when the COM00 and COM01 is cleared */
						break;
						case Toggle_PB_InCM:
							 RESET_Bit(TCCR2, COM21);
     464:	85 b5       	in	r24, 0x25	; 37
     466:	8f 7d       	andi	r24, 0xDF	; 223
     468:	85 bd       	out	0x25, r24	; 37
							 SET_Bit(TCCR2, COM20);
     46a:	85 b5       	in	r24, 0x25	; 37
     46c:	80 61       	ori	r24, 0x10	; 16
     46e:	85 bd       	out	0x25, r24	; 37
						break;
     470:	e8 cf       	rjmp	.-48     	; 0x442 <TIMER_WAVEGEN_NPWM+0x22>
					case Toggle_PB_InCM:
						 RESET_Bit(TCCR0, COM01);
						 SET_Bit(TCCR0, COM00);
					break;
					case Clear_PB_InCM:
						 SET_Bit(TCCR0, COM01);
     472:	83 b7       	in	r24, 0x33	; 51
     474:	80 62       	ori	r24, 0x20	; 32
     476:	83 bf       	out	0x33, r24	; 51
						 RESET_Bit(TCCR0, COM00);
     478:	83 b7       	in	r24, 0x33	; 51
     47a:	8f 7e       	andi	r24, 0xEF	; 239
     47c:	83 bf       	out	0x33, r24	; 51
					break;
     47e:	e1 cf       	rjmp	.-62     	; 0x442 <TIMER_WAVEGEN_NPWM+0x22>
						case Clear_PB_InCM:
							 SET_Bit(TCCR2, COM21);
							 RESET_Bit(TCCR2, COM20);
						break;
						case Set_PB_InCM:
							SET_Bit(TCCR2, COM21);
     480:	85 b5       	in	r24, 0x25	; 37
     482:	80 62       	ori	r24, 0x20	; 32
     484:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM20);
     486:	85 b5       	in	r24, 0x25	; 37
     488:	80 61       	ori	r24, 0x10	; 16
     48a:	85 bd       	out	0x25, r24	; 37
							break;
     48c:	da cf       	rjmp	.-76     	; 0x442 <TIMER_WAVEGEN_NPWM+0x22>
					case Clear_PB_InCM:
						 SET_Bit(TCCR0, COM01);
						 RESET_Bit(TCCR0, COM00);
					break;
					case Set_PB_InCM:
						SET_Bit(TCCR0, COM01);
     48e:	83 b7       	in	r24, 0x33	; 51
     490:	80 62       	ori	r24, 0x20	; 32
     492:	83 bf       	out	0x33, r24	; 51
						SET_Bit(TCCR0, COM00);
     494:	83 b7       	in	r24, 0x33	; 51
     496:	80 61       	ori	r24, 0x10	; 16
     498:	83 bf       	out	0x33, r24	; 51
						break;
     49a:	d3 cf       	rjmp	.-90     	; 0x442 <TIMER_WAVEGEN_NPWM+0x22>
				{
					case NON:
					/* This is The Normal State when the COM00 and COM01 is cleared */
					break;
					case Toggle_PB_InCM:
						 RESET_Bit(TCCR0, COM01);
     49c:	83 b7       	in	r24, 0x33	; 51
     49e:	8f 7d       	andi	r24, 0xDF	; 223
     4a0:	83 bf       	out	0x33, r24	; 51
						 SET_Bit(TCCR0, COM00);
     4a2:	83 b7       	in	r24, 0x33	; 51
     4a4:	80 61       	ori	r24, 0x10	; 16
     4a6:	83 bf       	out	0x33, r24	; 51
					break;
     4a8:	cc cf       	rjmp	.-104    	; 0x442 <TIMER_WAVEGEN_NPWM+0x22>
						case Toggle_PB_InCM:
							 RESET_Bit(TCCR2, COM21);
							 SET_Bit(TCCR2, COM20);
						break;
						case Clear_PB_InCM:
							 SET_Bit(TCCR2, COM21);
     4aa:	85 b5       	in	r24, 0x25	; 37
     4ac:	80 62       	ori	r24, 0x20	; 32
     4ae:	85 bd       	out	0x25, r24	; 37
							 RESET_Bit(TCCR2, COM20);
     4b0:	85 b5       	in	r24, 0x25	; 37
     4b2:	8f 7e       	andi	r24, 0xEF	; 239
     4b4:	85 bd       	out	0x25, r24	; 37
						break;
     4b6:	c5 cf       	rjmp	.-118    	; 0x442 <TIMER_WAVEGEN_NPWM+0x22>

000004b8 <TIMER_WAVEGEN_FASTPWM>:
			break;
		}
	
	}	
	void TIMER_WAVEGEN_FASTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     4b8:	cf 93       	push	r28
     4ba:	c4 2f       	mov	r28, r20
		switch(t.timer_Number)
     4bc:	66 23       	and	r22, r22
     4be:	a9 f4       	brne	.+42     	; 0x4ea <TIMER_WAVEGEN_FASTPWM+0x32>
				  *
				  * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				  * if the user choose the inverting mode this result become the OFF time ratio 
				  * and if decide non inverting mode this ratio become the ON time ratio 
				  */
				OCR0 = Top_Value;
     4c0:	2c bf       	out	0x3c, r18	; 60
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     4c2:	86 e3       	ldi	r24, 0x36	; 54
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	63 e0       	ldi	r22, 0x03	; 3
     4c8:	42 e0       	ldi	r20, 0x02	; 2
     4ca:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
		
				/* Note 
					* the case of COM00 , COM01 is decimal 1 is reserved ( Not use ) 
					*/
				switch(wave)
     4ce:	c4 30       	cpi	r28, 0x04	; 4
     4d0:	19 f1       	breq	.+70     	; 0x518 <TIMER_WAVEGEN_FASTPWM+0x60>
     4d2:	c5 30       	cpi	r28, 0x05	; 5
     4d4:	11 f0       	breq	.+4      	; 0x4da <TIMER_WAVEGEN_FASTPWM+0x22>
     4d6:	cc 23       	and	r28, r28
     4d8:	31 f4       	brne	.+12     	; 0x4e6 <TIMER_WAVEGEN_FASTPWM+0x2e>
					case NON:
							/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
				 
					case NonInverting_FPWM:
							/* This mode when the signal on the OC0 is cleared when happen Compare match with the value on OCR0 and Set when TCCR0  reach bottom (Overflow) */
							RESET_Bit(TCCR0, COM00);
     4da:	83 b7       	in	r24, 0x33	; 51
     4dc:	8f 7e       	andi	r24, 0xEF	; 239
     4de:	83 bf       	out	0x33, r24	; 51
							SET_Bit(TCCR0, COM01);
     4e0:	83 b7       	in	r24, 0x33	; 51
     4e2:	80 62       	ori	r24, 0x20	; 32
     4e4:	83 bf       	out	0x33, r24	; 51
			default :
			break;
		}
		
		
	}	
     4e6:	cf 91       	pop	r28
     4e8:	08 95       	ret
		}
	
	}	
	void TIMER_WAVEGEN_FASTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     4ea:	61 30       	cpi	r22, 0x01	; 1
     4ec:	e1 f7       	brne	.-8      	; 0x4e6 <TIMER_WAVEGEN_FASTPWM+0x2e>
				  *
				  * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				  * if the user choose the inverting mode this result become the OFF time ratio 
				  * and if decide non inverting mode this ratio become the ON time ratio 
				  */
				OCR2 = Top_Value;
     4ee:	23 bd       	out	0x23, r18	; 35
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOD,PIN7, Output);
     4f0:	80 e3       	ldi	r24, 0x30	; 48
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	67 e0       	ldi	r22, 0x07	; 7
     4f6:	42 e0       	ldi	r20, 0x02	; 2
     4f8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
		
				/* Note 
					* the case of COM20 , COM21 is decimal 1 is reserved ( Not use ) 
					*/
				switch(wave)
     4fc:	c4 30       	cpi	r28, 0x04	; 4
     4fe:	a1 f0       	breq	.+40     	; 0x528 <TIMER_WAVEGEN_FASTPWM+0x70>
     500:	c5 30       	cpi	r28, 0x05	; 5
     502:	11 f0       	breq	.+4      	; 0x508 <TIMER_WAVEGEN_FASTPWM+0x50>
     504:	cc 23       	and	r28, r28
     506:	79 f7       	brne	.-34     	; 0x4e6 <TIMER_WAVEGEN_FASTPWM+0x2e>
					case NON:
							/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
				 
					case NonInverting_FPWM:
							/* This mode when the signal on the OC0 is cleared when happen Compare match with the value on OCR0 and Set when TCCR0  reach bottom (Overflow) */
							RESET_Bit(TCCR2, COM20);
     508:	85 b5       	in	r24, 0x25	; 37
     50a:	8f 7e       	andi	r24, 0xEF	; 239
     50c:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM21);
     50e:	85 b5       	in	r24, 0x25	; 37
     510:	80 62       	ori	r24, 0x20	; 32
     512:	85 bd       	out	0x25, r24	; 37
			default :
			break;
		}
		
		
	}	
     514:	cf 91       	pop	r28
     516:	08 95       	ret
							RESET_Bit(TCCR0, COM00);
							SET_Bit(TCCR0, COM01);
					break;
					case Inverting_FPWM:
							/* This mode when the signal on the OC0 is set when happen Compare match with the value on OCR0 and Cleared when TCCR0  reach bottom (Overflow) */
							SET_Bit(TCCR0, COM00);
     518:	83 b7       	in	r24, 0x33	; 51
     51a:	80 61       	ori	r24, 0x10	; 16
     51c:	83 bf       	out	0x33, r24	; 51
							SET_Bit(TCCR0, COM01);
     51e:	83 b7       	in	r24, 0x33	; 51
     520:	80 62       	ori	r24, 0x20	; 32
     522:	83 bf       	out	0x33, r24	; 51
			default :
			break;
		}
		
		
	}	
     524:	cf 91       	pop	r28
     526:	08 95       	ret
							RESET_Bit(TCCR2, COM20);
							SET_Bit(TCCR2, COM21);
					break;
					case Inverting_FPWM:
							/* This mode when the signal on the OC0 is set when happen Compare match with the value on OCR0 and Cleared when TCCR0  reach bottom (Overflow) */
							SET_Bit(TCCR2, COM20);
     528:	85 b5       	in	r24, 0x25	; 37
     52a:	80 61       	ori	r24, 0x10	; 16
     52c:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM21);
     52e:	85 b5       	in	r24, 0x25	; 37
     530:	80 62       	ori	r24, 0x20	; 32
     532:	85 bd       	out	0x25, r24	; 37
			default :
			break;
		}
		
		
	}	
     534:	cf 91       	pop	r28
     536:	08 95       	ret

00000538 <TIMER_WAVEGEN_PHACECORRECTPWM>:
	
	
	void TIMER_WAVEGEN_PHACECORRECTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     538:	cf 93       	push	r28
     53a:	c4 2f       	mov	r28, r20
		switch(t.timer_Number)
     53c:	66 23       	and	r22, r22
     53e:	a9 f4       	brne	.+42     	; 0x56a <TIMER_WAVEGEN_PHACECORRECTPWM+0x32>
				 *
				 * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				 * if the user choose Set OC0 at up counting and Clear at down counting  mode this result become the OFF time ratio 
				 * and if decide Clear OC0 at up counting and Set at down counting  mode this ratio become the ON time ratio 
				 */
				OCR0 = Top_Value;
     540:	2c bf       	out	0x3c, r18	; 60
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     542:	86 e3       	ldi	r24, 0x36	; 54
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	63 e0       	ldi	r22, 0x03	; 3
     548:	42 e0       	ldi	r20, 0x02	; 2
     54a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
		
				/* Note 
				 * the case of COM00 , COM01 is decimal 1 is reserved ( Not use ) 
				 */
				switch(wave)
     54e:	c6 30       	cpi	r28, 0x06	; 6
     550:	21 f0       	breq	.+8      	; 0x55a <TIMER_WAVEGEN_PHACECORRECTPWM+0x22>
     552:	c7 30       	cpi	r28, 0x07	; 7
     554:	49 f1       	breq	.+82     	; 0x5a8 <TIMER_WAVEGEN_PHACECORRECTPWM+0x70>
     556:	cc 23       	and	r28, r28
     558:	31 f4       	brne	.+12     	; 0x566 <TIMER_WAVEGEN_PHACECORRECTPWM+0x2e>
					case NON:
					/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
			
					case ClearUp_SetDowen_PCPWM:
					/* This mode operation is the signal on the OC0 is clear when happen Compare match with the value on OCR0 at the up counting of the TCNT0 and Set when happen compare match at the down counting of the TCNT0 */
					RESET_Bit(TCCR0, COM00);
     55a:	83 b7       	in	r24, 0x33	; 51
     55c:	8f 7e       	andi	r24, 0xEF	; 239
     55e:	83 bf       	out	0x33, r24	; 51
					SET_Bit(TCCR0, COM01);
     560:	83 b7       	in	r24, 0x33	; 51
     562:	80 62       	ori	r24, 0x20	; 32
     564:	83 bf       	out	0x33, r24	; 51
			break;
			default: 
			
			break;
		}		
	}	
     566:	cf 91       	pop	r28
     568:	08 95       	ret
	}	
	
	
	void TIMER_WAVEGEN_PHACECORRECTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     56a:	61 30       	cpi	r22, 0x01	; 1
     56c:	e1 f7       	brne	.-8      	; 0x566 <TIMER_WAVEGEN_PHACECORRECTPWM+0x2e>
				 *
				 * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				 * if the user choose Set OC2 at up counting and Clear at down counting  mode this result become the OFF time ratio 
				 * and if decide Clear OC2 at up counting and Set at down counting  mode this ratio become the ON time ratio 
				 */
				OCR2 = Top_Value;
     56e:	23 bd       	out	0x23, r18	; 35
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOD,PIN7, Output);
     570:	80 e3       	ldi	r24, 0x30	; 48
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	67 e0       	ldi	r22, 0x07	; 7
     576:	42 e0       	ldi	r20, 0x02	; 2
     578:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
		
				/* Note 
				 * the case of COM20 , COM21 is decimal 1 is reserved ( Not use ) 
				 */
				switch(wave)
     57c:	c6 30       	cpi	r28, 0x06	; 6
     57e:	21 f0       	breq	.+8      	; 0x588 <TIMER_WAVEGEN_PHACECORRECTPWM+0x50>
     580:	c7 30       	cpi	r28, 0x07	; 7
     582:	51 f0       	breq	.+20     	; 0x598 <TIMER_WAVEGEN_PHACECORRECTPWM+0x60>
     584:	cc 23       	and	r28, r28
     586:	79 f7       	brne	.-34     	; 0x566 <TIMER_WAVEGEN_PHACECORRECTPWM+0x2e>
					case NON:
					/* This IS the normal mode OC2 IS disconnected when the COM20 and COM21 is cleared  */
			
					case ClearUp_SetDowen_PCPWM:
					/* This mode operation is the signal on the OC2 is clear when happen Compare match with the value on OCR2 at the up counting of the TCNT0 and Set when happen compare match at the down counting of the TCNT0 */
					RESET_Bit(TCCR2, COM20);
     588:	85 b5       	in	r24, 0x25	; 37
     58a:	8f 7e       	andi	r24, 0xEF	; 239
     58c:	85 bd       	out	0x25, r24	; 37
					SET_Bit(TCCR2, COM21);
     58e:	85 b5       	in	r24, 0x25	; 37
     590:	80 62       	ori	r24, 0x20	; 32
     592:	85 bd       	out	0x25, r24	; 37
			break;
			default: 
			
			break;
		}		
	}	
     594:	cf 91       	pop	r28
     596:	08 95       	ret
					RESET_Bit(TCCR2, COM20);
					SET_Bit(TCCR2, COM21);
					break;
					case SetUp_ClearDowen_PCPWM:
					/* This mode operation is the signal on the OC2 is set when happen Compare match with the value on OCR2 at the up counting of the TCNT0 and clear when happen compare match at the down counting of the TCNT0 */
					SET_Bit(TCCR2, COM20);
     598:	85 b5       	in	r24, 0x25	; 37
     59a:	80 61       	ori	r24, 0x10	; 16
     59c:	85 bd       	out	0x25, r24	; 37
					SET_Bit(TCCR2, COM21);
     59e:	85 b5       	in	r24, 0x25	; 37
     5a0:	80 62       	ori	r24, 0x20	; 32
     5a2:	85 bd       	out	0x25, r24	; 37
			break;
			default: 
			
			break;
		}		
	}	
     5a4:	cf 91       	pop	r28
     5a6:	08 95       	ret
					RESET_Bit(TCCR0, COM00);
					SET_Bit(TCCR0, COM01);
					break;
					case SetUp_ClearDowen_PCPWM:
					/* This mode operation is the signal on the OC0 is set when happen Compare match with the value on OCR0 at the up counting of the TCNT0 and clear when happen compare match at the down counting of the TCNT0 */
					SET_Bit(TCCR0, COM00);
     5a8:	83 b7       	in	r24, 0x33	; 51
     5aa:	80 61       	ori	r24, 0x10	; 16
     5ac:	83 bf       	out	0x33, r24	; 51
					SET_Bit(TCCR0, COM01);
     5ae:	83 b7       	in	r24, 0x33	; 51
     5b0:	80 62       	ori	r24, 0x20	; 32
     5b2:	83 bf       	out	0x33, r24	; 51
			break;
			default: 
			
			break;
		}		
	}	
     5b4:	cf 91       	pop	r28
     5b6:	08 95       	ret

000005b8 <sevenSegment_setup>:
  #define bit_2_num (2)
  #define bit_3_num (3)
  
  
  void sevenSegment_setup(SevenSegment pins)
  {
     5b8:	0f 93       	push	r16
     5ba:	1f 93       	push	r17
     5bc:	cf 93       	push	r28
     5be:	df 93       	push	r29
     5c0:	00 d0       	rcall	.+0      	; 0x5c2 <sevenSegment_setup+0xa>
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <sevenSegment_setup+0xc>
     5c4:	00 d0       	rcall	.+0      	; 0x5c6 <sevenSegment_setup+0xe>
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	49 83       	std	Y+1, r20	; 0x01
     5cc:	5a 83       	std	Y+2, r21	; 0x02
     5ce:	6b 83       	std	Y+3, r22	; 0x03
     5d0:	7c 83       	std	Y+4, r23	; 0x04
     5d2:	8d 83       	std	Y+5, r24	; 0x05
     5d4:	9e 83       	std	Y+6, r25	; 0x06
     5d6:	09 81       	ldd	r16, Y+1	; 0x01
     5d8:	1a 81       	ldd	r17, Y+2	; 0x02
	  /* define The Pins Of The BCD IC As Output Pins */
	  DIO_pinConfiguration(pins.drivPORT,pins.Apin,Output);
     5da:	c8 01       	movw	r24, r16
     5dc:	42 e0       	ldi	r20, 0x02	; 2
     5de:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	  DIO_pinConfiguration(pins.drivPORT,pins.Bpin,Output);
     5e2:	c8 01       	movw	r24, r16
     5e4:	6c 81       	ldd	r22, Y+4	; 0x04
     5e6:	42 e0       	ldi	r20, 0x02	; 2
     5e8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	  DIO_pinConfiguration(pins.drivPORT,pins.Cpin,Output);
     5ec:	c8 01       	movw	r24, r16
     5ee:	6d 81       	ldd	r22, Y+5	; 0x05
     5f0:	42 e0       	ldi	r20, 0x02	; 2
     5f2:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	  DIO_pinConfiguration(pins.drivPORT,pins.Dpin,Output);
     5f6:	c8 01       	movw	r24, r16
     5f8:	6e 81       	ldd	r22, Y+6	; 0x06
     5fa:	42 e0       	ldi	r20, 0x02	; 2
     5fc:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
  }
     600:	26 96       	adiw	r28, 0x06	; 6
     602:	0f b6       	in	r0, 0x3f	; 63
     604:	f8 94       	cli
     606:	de bf       	out	0x3e, r29	; 62
     608:	0f be       	out	0x3f, r0	; 63
     60a:	cd bf       	out	0x3d, r28	; 61
     60c:	df 91       	pop	r29
     60e:	cf 91       	pop	r28
     610:	1f 91       	pop	r17
     612:	0f 91       	pop	r16
     614:	08 95       	ret

00000616 <sevenSegment_write>:
  
  
  void sevenSegment_write(SevenSegment pins, unsigned char number)
  {
     616:	ef 92       	push	r14
     618:	ff 92       	push	r15
     61a:	0f 93       	push	r16
     61c:	1f 93       	push	r17
     61e:	cf 93       	push	r28
     620:	df 93       	push	r29
     622:	cd b7       	in	r28, 0x3d	; 61
     624:	de b7       	in	r29, 0x3e	; 62
     626:	27 97       	sbiw	r28, 0x07	; 7
     628:	0f b6       	in	r0, 0x3f	; 63
     62a:	f8 94       	cli
     62c:	de bf       	out	0x3e, r29	; 62
     62e:	0f be       	out	0x3f, r0	; 63
     630:	cd bf       	out	0x3d, r28	; 61
     632:	49 83       	std	Y+1, r20	; 0x01
     634:	5a 83       	std	Y+2, r21	; 0x02
     636:	6b 83       	std	Y+3, r22	; 0x03
     638:	7c 83       	std	Y+4, r23	; 0x04
     63a:	8d 83       	std	Y+5, r24	; 0x05
     63c:	9e 83       	std	Y+6, r25	; 0x06
     63e:	09 81       	ldd	r16, Y+1	; 0x01
     640:	1a 81       	ldd	r17, Y+2	; 0x02
	  /* read The Bit Zero from The Number And represent By The Pin A */
	  DIO_pinWrite(pins.drivPORT,pins.Apin, (READ_Bit(number,bit_0_num)));
     642:	42 2f       	mov	r20, r18
     644:	41 70       	andi	r20, 0x01	; 1
     646:	c8 01       	movw	r24, r16
     648:	2f 83       	std	Y+7, r18	; 0x07
     64a:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
	  /* read The Bit 1 from The Number And represent By The Pin B */
	  DIO_pinWrite(pins.drivPORT,pins.Bpin, (READ_Bit(number,bit_1_num)));
     64e:	2f 81       	ldd	r18, Y+7	; 0x07
     650:	e2 2e       	mov	r14, r18
     652:	ff 24       	eor	r15, r15
     654:	a7 01       	movw	r20, r14
     656:	42 70       	andi	r20, 0x02	; 2
     658:	50 70       	andi	r21, 0x00	; 0
     65a:	55 95       	asr	r21
     65c:	47 95       	ror	r20
     65e:	c8 01       	movw	r24, r16
     660:	6c 81       	ldd	r22, Y+4	; 0x04
     662:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
	  /* read The Bit 2 from The Number And represent By The Pin C */
	  DIO_pinWrite(pins.drivPORT,pins.Cpin, (READ_Bit(number,bit_2_num)));
     666:	a7 01       	movw	r20, r14
     668:	44 70       	andi	r20, 0x04	; 4
     66a:	50 70       	andi	r21, 0x00	; 0
     66c:	55 95       	asr	r21
     66e:	47 95       	ror	r20
     670:	55 95       	asr	r21
     672:	47 95       	ror	r20
     674:	c8 01       	movw	r24, r16
     676:	6d 81       	ldd	r22, Y+5	; 0x05
     678:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
	  /* read The Bit 3 from The Number And represent By The Pin D */
	  DIO_pinWrite(pins.drivPORT,pins.Dpin, (READ_Bit(number,bit_3_num)));
     67c:	a7 01       	movw	r20, r14
     67e:	48 70       	andi	r20, 0x08	; 8
     680:	50 70       	andi	r21, 0x00	; 0
     682:	55 95       	asr	r21
     684:	47 95       	ror	r20
     686:	55 95       	asr	r21
     688:	47 95       	ror	r20
     68a:	55 95       	asr	r21
     68c:	47 95       	ror	r20
     68e:	c8 01       	movw	r24, r16
     690:	6e 81       	ldd	r22, Y+6	; 0x06
     692:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
     696:	27 96       	adiw	r28, 0x07	; 7
     698:	0f b6       	in	r0, 0x3f	; 63
     69a:	f8 94       	cli
     69c:	de bf       	out	0x3e, r29	; 62
     69e:	0f be       	out	0x3f, r0	; 63
     6a0:	cd bf       	out	0x3d, r28	; 61
     6a2:	df 91       	pop	r29
     6a4:	cf 91       	pop	r28
     6a6:	1f 91       	pop	r17
     6a8:	0f 91       	pop	r16
     6aa:	ff 90       	pop	r15
     6ac:	ef 90       	pop	r14
     6ae:	08 95       	ret

000006b0 <CheckData.isra.0>:
	
	
	
	 
 /* This is an static function to check the value of the current data get from the keypad key */
 static unsigned char CheckData(KEYPAD_PIN keypad,MATRIX_COL col )
     6b0:	df 92       	push	r13
     6b2:	ef 92       	push	r14
     6b4:	ff 92       	push	r15
     6b6:	0f 93       	push	r16
     6b8:	1f 93       	push	r17
     6ba:	cf 93       	push	r28
     6bc:	df 93       	push	r29
     6be:	ec 01       	movw	r28, r24
     6c0:	16 2f       	mov	r17, r22
     6c2:	f4 2e       	mov	r15, r20
     6c4:	d2 2e       	mov	r13, r18
 {
	 /* Each time We Check If The User Is Push The button by Check the value get on The Raw Pin if HIGH the button pushed else we check the other Raw */ 
	 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW1))
     6c6:	0e 94 9b 00 	call	0x136	; 0x136 <DIO_pinRead>
     6ca:	88 23       	and	r24, r24
     6cc:	c9 f0       	breq	.+50     	; 0x700 <CheckData.isra.0+0x50>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6ce:	8f e7       	ldi	r24, 0x7F	; 127
     6d0:	92 e3       	ldi	r25, 0x32	; 50
     6d2:	a2 e0       	ldi	r26, 0x02	; 2
     6d4:	81 50       	subi	r24, 0x01	; 1
     6d6:	90 40       	sbci	r25, 0x00	; 0
     6d8:	a0 40       	sbci	r26, 0x00	; 0
     6da:	e1 f7       	brne	.-8      	; 0x6d4 <CheckData.isra.0+0x24>
     6dc:	00 c0       	rjmp	.+0      	; 0x6de <CheckData.isra.0+0x2e>
     6de:	00 00       	nop
	 {
		 /* wait Time Delay and recheck the condition of the Raw pin to Make Sure The Is Not An Noise */
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW1))
     6e0:	ce 01       	movw	r24, r28
     6e2:	61 2f       	mov	r22, r17
     6e4:	0e 94 9b 00 	call	0x136	; 0x136 <DIO_pinRead>
     6e8:	88 23       	and	r24, r24
     6ea:	09 f0       	breq	.+2      	; 0x6ee <CheckData.isra.0+0x3e>
     6ec:	47 c0       	rjmp	.+142    	; 0x77c <CheckData.isra.0+0xcc>
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW4))
		 {
			 return(KeyData[ROW4][col]);
		 }
	 }
	 return 0;
     6ee:	80 e0       	ldi	r24, 0x00	; 0
	 
 }
     6f0:	df 91       	pop	r29
     6f2:	cf 91       	pop	r28
     6f4:	1f 91       	pop	r17
     6f6:	0f 91       	pop	r16
     6f8:	ff 90       	pop	r15
     6fa:	ef 90       	pop	r14
     6fc:	df 90       	pop	r13
     6fe:	08 95       	ret
		 {
			 /* We Match the Value Get From The REad Function Of The Number Of The Column And The Number Of The Raw We Get Here To Get The Value From The Matrix */
			return(KeyData[ROW1][col]);
		 }			 
	 }
	 else if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW2))
     700:	ce 01       	movw	r24, r28
     702:	6f 2d       	mov	r22, r15
     704:	0e 94 9b 00 	call	0x136	; 0x136 <DIO_pinRead>
     708:	88 23       	and	r24, r24
     70a:	e1 f0       	breq	.+56     	; 0x744 <CheckData.isra.0+0x94>
     70c:	8f e7       	ldi	r24, 0x7F	; 127
     70e:	92 e3       	ldi	r25, 0x32	; 50
     710:	a2 e0       	ldi	r26, 0x02	; 2
     712:	81 50       	subi	r24, 0x01	; 1
     714:	90 40       	sbci	r25, 0x00	; 0
     716:	a0 40       	sbci	r26, 0x00	; 0
     718:	e1 f7       	brne	.-8      	; 0x712 <CheckData.isra.0+0x62>
     71a:	00 c0       	rjmp	.+0      	; 0x71c <CheckData.isra.0+0x6c>
     71c:	00 00       	nop
	 {
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW2))
     71e:	ce 01       	movw	r24, r28
     720:	6f 2d       	mov	r22, r15
     722:	0e 94 9b 00 	call	0x136	; 0x136 <DIO_pinRead>
     726:	88 23       	and	r24, r24
     728:	11 f3       	breq	.-60     	; 0x6ee <CheckData.isra.0+0x3e>
		 {
			  return(KeyData[ROW2][col]);
     72a:	ee 2d       	mov	r30, r14
     72c:	f0 e0       	ldi	r31, 0x00	; 0
     72e:	e1 53       	subi	r30, 0x31	; 49
     730:	ff 4f       	sbci	r31, 0xFF	; 255
     732:	84 81       	ldd	r24, Z+4	; 0x04
			 return(KeyData[ROW4][col]);
		 }
	 }
	 return 0;
	 
 }
     734:	df 91       	pop	r29
     736:	cf 91       	pop	r28
     738:	1f 91       	pop	r17
     73a:	0f 91       	pop	r16
     73c:	ff 90       	pop	r15
     73e:	ef 90       	pop	r14
     740:	df 90       	pop	r13
     742:	08 95       	ret
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW2))
		 {
			  return(KeyData[ROW2][col]);
		 }
	 }
	 else if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW3))
     744:	ce 01       	movw	r24, r28
     746:	6d 2d       	mov	r22, r13
     748:	0e 94 9b 00 	call	0x136	; 0x136 <DIO_pinRead>
     74c:	88 23       	and	r24, r24
     74e:	19 f1       	breq	.+70     	; 0x796 <CheckData.isra.0+0xe6>
     750:	8f e7       	ldi	r24, 0x7F	; 127
     752:	92 e3       	ldi	r25, 0x32	; 50
     754:	a2 e0       	ldi	r26, 0x02	; 2
     756:	81 50       	subi	r24, 0x01	; 1
     758:	90 40       	sbci	r25, 0x00	; 0
     75a:	a0 40       	sbci	r26, 0x00	; 0
     75c:	e1 f7       	brne	.-8      	; 0x756 <CheckData.isra.0+0xa6>
     75e:	00 c0       	rjmp	.+0      	; 0x760 <CheckData.isra.0+0xb0>
     760:	00 00       	nop
	 {
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW3))
     762:	ce 01       	movw	r24, r28
     764:	6d 2d       	mov	r22, r13
     766:	0e 94 9b 00 	call	0x136	; 0x136 <DIO_pinRead>
     76a:	88 23       	and	r24, r24
     76c:	09 f4       	brne	.+2      	; 0x770 <CheckData.isra.0+0xc0>
     76e:	bf cf       	rjmp	.-130    	; 0x6ee <CheckData.isra.0+0x3e>
		 {
			return(KeyData[ROW3][col]);
     770:	ee 2d       	mov	r30, r14
     772:	f0 e0       	ldi	r31, 0x00	; 0
     774:	e1 53       	subi	r30, 0x31	; 49
     776:	ff 4f       	sbci	r31, 0xFF	; 255
     778:	80 85       	ldd	r24, Z+8	; 0x08
     77a:	ba cf       	rjmp	.-140    	; 0x6f0 <CheckData.isra.0+0x40>
		 /* wait Time Delay and recheck the condition of the Raw pin to Make Sure The Is Not An Noise */
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW1))
		 {
			 /* We Match the Value Get From The REad Function Of The Number Of The Column And The Number Of The Raw We Get Here To Get The Value From The Matrix */
			return(KeyData[ROW1][col]);
     77c:	ee 2d       	mov	r30, r14
     77e:	f0 e0       	ldi	r31, 0x00	; 0
     780:	e1 53       	subi	r30, 0x31	; 49
     782:	ff 4f       	sbci	r31, 0xFF	; 255
     784:	80 81       	ld	r24, Z
			 return(KeyData[ROW4][col]);
		 }
	 }
	 return 0;
	 
 }
     786:	df 91       	pop	r29
     788:	cf 91       	pop	r28
     78a:	1f 91       	pop	r17
     78c:	0f 91       	pop	r16
     78e:	ff 90       	pop	r15
     790:	ef 90       	pop	r14
     792:	df 90       	pop	r13
     794:	08 95       	ret
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW3))
		 {
			return(KeyData[ROW3][col]);
		 }
	 }
	 else if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW4))
     796:	ce 01       	movw	r24, r28
     798:	60 2f       	mov	r22, r16
     79a:	0e 94 9b 00 	call	0x136	; 0x136 <DIO_pinRead>
     79e:	88 23       	and	r24, r24
     7a0:	09 f4       	brne	.+2      	; 0x7a4 <CheckData.isra.0+0xf4>
     7a2:	a5 cf       	rjmp	.-182    	; 0x6ee <CheckData.isra.0+0x3e>
     7a4:	8f e7       	ldi	r24, 0x7F	; 127
     7a6:	92 e3       	ldi	r25, 0x32	; 50
     7a8:	a2 e0       	ldi	r26, 0x02	; 2
     7aa:	81 50       	subi	r24, 0x01	; 1
     7ac:	90 40       	sbci	r25, 0x00	; 0
     7ae:	a0 40       	sbci	r26, 0x00	; 0
     7b0:	e1 f7       	brne	.-8      	; 0x7aa <CheckData.isra.0+0xfa>
     7b2:	00 c0       	rjmp	.+0      	; 0x7b4 <CheckData.isra.0+0x104>
     7b4:	00 00       	nop
	 {
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW4))
     7b6:	ce 01       	movw	r24, r28
     7b8:	60 2f       	mov	r22, r16
     7ba:	0e 94 9b 00 	call	0x136	; 0x136 <DIO_pinRead>
     7be:	88 23       	and	r24, r24
     7c0:	09 f4       	brne	.+2      	; 0x7c4 <CheckData.isra.0+0x114>
     7c2:	95 cf       	rjmp	.-214    	; 0x6ee <CheckData.isra.0+0x3e>
		 {
			 return(KeyData[ROW4][col]);
     7c4:	ee 2d       	mov	r30, r14
     7c6:	f0 e0       	ldi	r31, 0x00	; 0
     7c8:	e1 53       	subi	r30, 0x31	; 49
     7ca:	ff 4f       	sbci	r31, 0xFF	; 255
     7cc:	84 85       	ldd	r24, Z+12	; 0x0c
     7ce:	90 cf       	rjmp	.-224    	; 0x6f0 <CheckData.isra.0+0x40>

000007d0 <keypad_Intiat>:
	 return 0;
	 
 }
 
 void keypad_Intiat (KEYPAD_PIN keypad)
 {
     7d0:	0f 93       	push	r16
     7d2:	1f 93       	push	r17
     7d4:	cf 93       	push	r28
     7d6:	df 93       	push	r29
     7d8:	cd b7       	in	r28, 0x3d	; 61
     7da:	de b7       	in	r29, 0x3e	; 62
     7dc:	2a 97       	sbiw	r28, 0x0a	; 10
     7de:	0f b6       	in	r0, 0x3f	; 63
     7e0:	f8 94       	cli
     7e2:	de bf       	out	0x3e, r29	; 62
     7e4:	0f be       	out	0x3f, r0	; 63
     7e6:	cd bf       	out	0x3d, r28	; 61
     7e8:	09 83       	std	Y+1, r16	; 0x01
     7ea:	1a 83       	std	Y+2, r17	; 0x02
     7ec:	2b 83       	std	Y+3, r18	; 0x03
     7ee:	3c 83       	std	Y+4, r19	; 0x04
     7f0:	4d 83       	std	Y+5, r20	; 0x05
     7f2:	5e 83       	std	Y+6, r21	; 0x06
     7f4:	6f 83       	std	Y+7, r22	; 0x07
     7f6:	78 87       	std	Y+8, r23	; 0x08
     7f8:	89 87       	std	Y+9, r24	; 0x09
     7fa:	9a 87       	std	Y+10, r25	; 0x0a
     7fc:	09 81       	ldd	r16, Y+1	; 0x01
     7fe:	1a 81       	ldd	r17, Y+2	; 0x02
	 /* Set the all pins of the Keypad input & And Make Its Initial Value Is Float by Set 0 To The Port And Connect a PullDowen Resistance */
	 DIO_portConfiguration(keypad.keypadREG_Port,0x00);
     800:	c8 01       	movw	r24, r16
     802:	60 e0       	ldi	r22, 0x00	; 0
     804:	0e 94 ae 00 	call	0x15c	; 0x15c <DIO_portConfiguration>
	 DIO_portWrite(keypad.keypadREG_Port,0x00);
     808:	c8 01       	movw	r24, r16
     80a:	60 e0       	ldi	r22, 0x00	; 0
     80c:	0e 94 b1 00 	call	0x162	; 0x162 <DIO_portWrite>
 }
     810:	2a 96       	adiw	r28, 0x0a	; 10
     812:	0f b6       	in	r0, 0x3f	; 63
     814:	f8 94       	cli
     816:	de bf       	out	0x3e, r29	; 62
     818:	0f be       	out	0x3f, r0	; 63
     81a:	cd bf       	out	0x3d, r28	; 61
     81c:	df 91       	pop	r29
     81e:	cf 91       	pop	r28
     820:	1f 91       	pop	r17
     822:	0f 91       	pop	r16
     824:	08 95       	ret

00000826 <keypad_Read>:
 
 
 unsigned char keypad_Read(KEYPAD_PIN keypad)
 {
     826:	5f 92       	push	r5
     828:	6f 92       	push	r6
     82a:	7f 92       	push	r7
     82c:	8f 92       	push	r8
     82e:	9f 92       	push	r9
     830:	af 92       	push	r10
     832:	bf 92       	push	r11
     834:	cf 92       	push	r12
     836:	df 92       	push	r13
     838:	ef 92       	push	r14
     83a:	ff 92       	push	r15
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	cf 93       	push	r28
     842:	df 93       	push	r29
     844:	cd b7       	in	r28, 0x3d	; 61
     846:	de b7       	in	r29, 0x3e	; 62
     848:	2a 97       	sbiw	r28, 0x0a	; 10
     84a:	0f b6       	in	r0, 0x3f	; 63
     84c:	f8 94       	cli
     84e:	de bf       	out	0x3e, r29	; 62
     850:	0f be       	out	0x3f, r0	; 63
     852:	cd bf       	out	0x3d, r28	; 61
     854:	09 83       	std	Y+1, r16	; 0x01
     856:	1a 83       	std	Y+2, r17	; 0x02
     858:	f2 2e       	mov	r15, r18
     85a:	2b 83       	std	Y+3, r18	; 0x03
     85c:	b3 2e       	mov	r11, r19
     85e:	3c 83       	std	Y+4, r19	; 0x04
     860:	a4 2e       	mov	r10, r20
     862:	4d 83       	std	Y+5, r20	; 0x05
     864:	15 2f       	mov	r17, r21
     866:	5e 83       	std	Y+6, r21	; 0x06
     868:	96 2e       	mov	r9, r22
     86a:	6f 83       	std	Y+7, r22	; 0x07
     86c:	87 2e       	mov	r8, r23
     86e:	78 87       	std	Y+8, r23	; 0x08
     870:	89 87       	std	Y+9, r24	; 0x09
     872:	9a 87       	std	Y+10, r25	; 0x0a
	 unsigned char DataRead = 0x00;
     874:	c9 80       	ldd	r12, Y+1	; 0x01
     876:	da 80       	ldd	r13, Y+2	; 0x02
     878:	78 2e       	mov	r7, r24
     87a:	69 2e       	mov	r6, r25
	 
	 /* CHECK IN THE COLUM 1 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL1,Output);
     87c:	c6 01       	movw	r24, r12
     87e:	42 e0       	ldi	r20, 0x02	; 2
     880:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL1,HIGH);
     884:	c6 01       	movw	r24, r12
     886:	69 2d       	mov	r22, r9
     888:	41 e0       	ldi	r20, 0x01	; 1
     88a:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
     
	 if (CheckData(keypad, COL1))
     88e:	c6 01       	movw	r24, r12
     890:	6f 2d       	mov	r22, r15
     892:	4b 2d       	mov	r20, r11
     894:	2a 2d       	mov	r18, r10
     896:	01 2f       	mov	r16, r17
     898:	ee 24       	eor	r14, r14
     89a:	0e 94 58 03 	call	0x6b0	; 0x6b0 <CheckData.isra.0>
     89e:	88 23       	and	r24, r24
     8a0:	09 f0       	breq	.+2      	; 0x8a4 <__stack+0x45>
     8a2:	9c c0       	rjmp	.+312    	; 0x9dc <__stack+0x17d>
 }
 
 
 unsigned char keypad_Read(KEYPAD_PIN keypad)
 {
	 unsigned char DataRead = 0x00;
     8a4:	55 24       	eor	r5, r5
	 if (CheckData(keypad, COL1))
	 { 
		 DataRead = CheckData(keypad, COL1);
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL1,InputFloat);
     8a6:	c6 01       	movw	r24, r12
     8a8:	69 2d       	mov	r22, r9
     8aa:	40 e0       	ldi	r20, 0x00	; 0
     8ac:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
     8b0:	8f e1       	ldi	r24, 0x1F	; 31
     8b2:	9e e4       	ldi	r25, 0x4E	; 78
     8b4:	01 97       	sbiw	r24, 0x01	; 1
     8b6:	f1 f7       	brne	.-4      	; 0x8b4 <__stack+0x55>
     8b8:	00 c0       	rjmp	.+0      	; 0x8ba <__stack+0x5b>
     8ba:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	
	 /* CHECK IN THE COLUM 2 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL2,Output);
     8bc:	c6 01       	movw	r24, r12
     8be:	68 2d       	mov	r22, r8
     8c0:	42 e0       	ldi	r20, 0x02	; 2
     8c2:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL2,HIGH);
     8c6:	c6 01       	movw	r24, r12
     8c8:	68 2d       	mov	r22, r8
     8ca:	41 e0       	ldi	r20, 0x01	; 1
     8cc:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
     
	 if (CheckData(keypad, COL2))
     8d0:	c6 01       	movw	r24, r12
     8d2:	6f 2d       	mov	r22, r15
     8d4:	4b 2d       	mov	r20, r11
     8d6:	2a 2d       	mov	r18, r10
     8d8:	01 2f       	mov	r16, r17
     8da:	ee 24       	eor	r14, r14
     8dc:	e3 94       	inc	r14
     8de:	0e 94 58 03 	call	0x6b0	; 0x6b0 <CheckData.isra.0>
     8e2:	88 23       	and	r24, r24
     8e4:	09 f0       	breq	.+2      	; 0x8e8 <__stack+0x89>
     8e6:	72 c0       	rjmp	.+228    	; 0x9cc <__stack+0x16d>
	 {
		 DataRead = CheckData(keypad, COL2);
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL2,InputFloat);
     8e8:	c6 01       	movw	r24, r12
     8ea:	68 2d       	mov	r22, r8
     8ec:	40 e0       	ldi	r20, 0x00	; 0
     8ee:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
     8f2:	8f e1       	ldi	r24, 0x1F	; 31
     8f4:	9e e4       	ldi	r25, 0x4E	; 78
     8f6:	01 97       	sbiw	r24, 0x01	; 1
     8f8:	f1 f7       	brne	.-4      	; 0x8f6 <__stack+0x97>
     8fa:	00 c0       	rjmp	.+0      	; 0x8fc <__stack+0x9d>
     8fc:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	 
	 /* CHECK IN THE COLUM 3 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL3,Output);
     8fe:	c6 01       	movw	r24, r12
     900:	67 2d       	mov	r22, r7
     902:	42 e0       	ldi	r20, 0x02	; 2
     904:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL3,HIGH);
     908:	c6 01       	movw	r24, r12
     90a:	67 2d       	mov	r22, r7
     90c:	41 e0       	ldi	r20, 0x01	; 1
     90e:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
     
	 if (CheckData(keypad, COL3))
     912:	c6 01       	movw	r24, r12
     914:	6f 2d       	mov	r22, r15
     916:	4b 2d       	mov	r20, r11
     918:	2a 2d       	mov	r18, r10
     91a:	01 2f       	mov	r16, r17
     91c:	52 e0       	ldi	r21, 0x02	; 2
     91e:	e5 2e       	mov	r14, r21
     920:	0e 94 58 03 	call	0x6b0	; 0x6b0 <CheckData.isra.0>
     924:	88 23       	and	r24, r24
     926:	09 f0       	breq	.+2      	; 0x92a <__stack+0xcb>
     928:	49 c0       	rjmp	.+146    	; 0x9bc <__stack+0x15d>
	 { 
		 DataRead = CheckData(keypad, COL3);
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL3,InputFloat);
     92a:	c6 01       	movw	r24, r12
     92c:	67 2d       	mov	r22, r7
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
     934:	8f e1       	ldi	r24, 0x1F	; 31
     936:	9e e4       	ldi	r25, 0x4E	; 78
     938:	01 97       	sbiw	r24, 0x01	; 1
     93a:	f1 f7       	brne	.-4      	; 0x938 <__stack+0xd9>
     93c:	00 c0       	rjmp	.+0      	; 0x93e <__stack+0xdf>
     93e:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	 
	 /* CHECK IN THE COLUM 4 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL4,Output);
     940:	c6 01       	movw	r24, r12
     942:	66 2d       	mov	r22, r6
     944:	42 e0       	ldi	r20, 0x02	; 2
     946:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL4,HIGH);
     94a:	c6 01       	movw	r24, r12
     94c:	66 2d       	mov	r22, r6
     94e:	41 e0       	ldi	r20, 0x01	; 1
     950:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
     
	 if (CheckData(keypad, COL4))
     954:	c6 01       	movw	r24, r12
     956:	6f 2d       	mov	r22, r15
     958:	4b 2d       	mov	r20, r11
     95a:	2a 2d       	mov	r18, r10
     95c:	01 2f       	mov	r16, r17
     95e:	33 e0       	ldi	r19, 0x03	; 3
     960:	e3 2e       	mov	r14, r19
     962:	0e 94 58 03 	call	0x6b0	; 0x6b0 <CheckData.isra.0>
     966:	88 23       	and	r24, r24
     968:	39 f0       	breq	.+14     	; 0x978 <__stack+0x119>
	 {
		 DataRead = CheckData(keypad, COL4);
     96a:	c6 01       	movw	r24, r12
     96c:	6f 2d       	mov	r22, r15
     96e:	4b 2d       	mov	r20, r11
     970:	2a 2d       	mov	r18, r10
     972:	0e 94 58 03 	call	0x6b0	; 0x6b0 <CheckData.isra.0>
     976:	58 2e       	mov	r5, r24
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL4,InputFloat);
     978:	c6 01       	movw	r24, r12
     97a:	66 2d       	mov	r22, r6
     97c:	40 e0       	ldi	r20, 0x00	; 0
     97e:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
     982:	8f e1       	ldi	r24, 0x1F	; 31
     984:	9e e4       	ldi	r25, 0x4E	; 78
     986:	01 97       	sbiw	r24, 0x01	; 1
     988:	f1 f7       	brne	.-4      	; 0x986 <__stack+0x127>
     98a:	00 c0       	rjmp	.+0      	; 0x98c <__stack+0x12d>
     98c:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	 return DataRead;
	 
     98e:	85 2d       	mov	r24, r5
     990:	2a 96       	adiw	r28, 0x0a	; 10
     992:	0f b6       	in	r0, 0x3f	; 63
     994:	f8 94       	cli
     996:	de bf       	out	0x3e, r29	; 62
     998:	0f be       	out	0x3f, r0	; 63
     99a:	cd bf       	out	0x3d, r28	; 61
     99c:	df 91       	pop	r29
     99e:	cf 91       	pop	r28
     9a0:	1f 91       	pop	r17
     9a2:	0f 91       	pop	r16
     9a4:	ff 90       	pop	r15
     9a6:	ef 90       	pop	r14
     9a8:	df 90       	pop	r13
     9aa:	cf 90       	pop	r12
     9ac:	bf 90       	pop	r11
     9ae:	af 90       	pop	r10
     9b0:	9f 90       	pop	r9
     9b2:	8f 90       	pop	r8
     9b4:	7f 90       	pop	r7
     9b6:	6f 90       	pop	r6
     9b8:	5f 90       	pop	r5
     9ba:	08 95       	ret
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL3,Output);
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL3,HIGH);
     
	 if (CheckData(keypad, COL3))
	 { 
		 DataRead = CheckData(keypad, COL3);
     9bc:	c6 01       	movw	r24, r12
     9be:	6f 2d       	mov	r22, r15
     9c0:	4b 2d       	mov	r20, r11
     9c2:	2a 2d       	mov	r18, r10
     9c4:	0e 94 58 03 	call	0x6b0	; 0x6b0 <CheckData.isra.0>
     9c8:	58 2e       	mov	r5, r24
     9ca:	af cf       	rjmp	.-162    	; 0x92a <__stack+0xcb>
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL2,Output);
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL2,HIGH);
     
	 if (CheckData(keypad, COL2))
	 {
		 DataRead = CheckData(keypad, COL2);
     9cc:	c6 01       	movw	r24, r12
     9ce:	6f 2d       	mov	r22, r15
     9d0:	4b 2d       	mov	r20, r11
     9d2:	2a 2d       	mov	r18, r10
     9d4:	0e 94 58 03 	call	0x6b0	; 0x6b0 <CheckData.isra.0>
     9d8:	58 2e       	mov	r5, r24
     9da:	86 cf       	rjmp	.-244    	; 0x8e8 <__stack+0x89>
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL1,Output);
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL1,HIGH);
     
	 if (CheckData(keypad, COL1))
	 { 
		 DataRead = CheckData(keypad, COL1);
     9dc:	c6 01       	movw	r24, r12
     9de:	6f 2d       	mov	r22, r15
     9e0:	4b 2d       	mov	r20, r11
     9e2:	2a 2d       	mov	r18, r10
     9e4:	0e 94 58 03 	call	0x6b0	; 0x6b0 <CheckData.isra.0>
     9e8:	58 2e       	mov	r5, r24
     9ea:	5d cf       	rjmp	.-326    	; 0x8a6 <__stack+0x47>

000009ec <Send_instruction>:
  #define MAX_NWCHAR   (8)
  
    void Send_instruction(unsigned char instruction)
	{
		/* The RS And The RW Must Be RESET When Send Instruction To The LCD */
		RESET_Bit(LCD_CONTROL_REG_OP, RS);
     9ec:	d8 98       	cbi	0x1b, 0	; 27
		RESET_Bit(LCD_CONTROL_REG_OP, RW);
     9ee:	d9 98       	cbi	0x1b, 1	; 27
     9f0:	ef e9       	ldi	r30, 0x9F	; 159
     9f2:	ff e0       	ldi	r31, 0x0F	; 15
     9f4:	31 97       	sbiw	r30, 0x01	; 1
     9f6:	f1 f7       	brne	.-4      	; 0x9f4 <Send_instruction+0x8>
     9f8:	00 c0       	rjmp	.+0      	; 0x9fa <Send_instruction+0xe>
     9fa:	00 00       	nop
		/* Delay of Address Set 60ns minimum This In The Ideal State */
		_delay_ms(1);
		
		/* We WriteTo the LCD InThe Falling Of The Enable Pin */
		/* Set The Enable Pin */
		SET_Bit(LCD_CONTROL_REG_OP, E);
     9fc:	da 9a       	sbi	0x1b, 2	; 27
     9fe:	ef e9       	ldi	r30, 0x9F	; 159
     a00:	ff e0       	ldi	r31, 0x0F	; 15
     a02:	31 97       	sbiw	r30, 0x01	; 1
     a04:	f1 f7       	brne	.-4      	; 0xa02 <Send_instruction+0x16>
     a06:	00 c0       	rjmp	.+0      	; 0xa08 <Send_instruction+0x1c>
     a08:	00 00       	nop
		
	   #else 
	        /* At The First We Send The MSB 4-bit Of The Instruction So We handle If The User Connect LCD in The Upper Or Lower Pin Of The Port */
	        #ifdef LCD_UPPER_DATA_PORT
			       /* Setup The Data Port To hold The Data By Reset the Upper Pin */
				   LCD_DATA_REG_OP &= 0x0F ; 
     a0a:	9b b3       	in	r25, 0x1b	; 27
     a0c:	9f 70       	andi	r25, 0x0F	; 15
     a0e:	9b bb       	out	0x1b, r25	; 27
				   LCD_DATA_REG_OP |= (instruction & 0xF0);
     a10:	2b b3       	in	r18, 0x1b	; 27
     a12:	98 2f       	mov	r25, r24
     a14:	90 7f       	andi	r25, 0xF0	; 240
     a16:	92 2b       	or	r25, r18
     a18:	9b bb       	out	0x1b, r25	; 27
     a1a:	ef e9       	ldi	r30, 0x9F	; 159
     a1c:	ff e0       	ldi	r31, 0x0F	; 15
     a1e:	31 97       	sbiw	r30, 0x01	; 1
     a20:	f1 f7       	brne	.-4      	; 0xa1e <Send_instruction+0x32>
     a22:	00 c0       	rjmp	.+0      	; 0xa24 <Send_instruction+0x38>
     a24:	00 00       	nop
			
			/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
			_delay_ms(1);
			
			/* disable LCD E=0 */
			RESET_Bit(LCD_CONTROL_REG_OP,E);
     a26:	da 98       	cbi	0x1b, 2	; 27
     a28:	ef e9       	ldi	r30, 0x9F	; 159
     a2a:	ff e0       	ldi	r31, 0x0F	; 15
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	f1 f7       	brne	.-4      	; 0xa2c <Send_instruction+0x40>
     a30:	00 c0       	rjmp	.+0      	; 0xa32 <Send_instruction+0x46>
     a32:	00 00       	nop
			/* Data Hold delay Th = 10ns */
			_delay_ms(1);
		    
			/* Reconfigure The E Pin To Prepare To Send The Next 4-bit LSB */
		    SET_Bit(LCD_CONTROL_REG_OP, E);
     a34:	da 9a       	sbi	0x1b, 2	; 27
     a36:	ef e9       	ldi	r30, 0x9F	; 159
     a38:	ff e0       	ldi	r31, 0x0F	; 15
     a3a:	31 97       	sbiw	r30, 0x01	; 1
     a3c:	f1 f7       	brne	.-4      	; 0xa3a <Send_instruction+0x4e>
     a3e:	00 c0       	rjmp	.+0      	; 0xa40 <Send_instruction+0x54>
     a40:	00 00       	nop
		    /* delay for processing PW min 450ns This In The Ideal State */
		    _delay_ms(1);
			
			#ifdef LCD_UPPER_DATA_PORT
			       /* Setup The Data Port To hold The Data By Reset the Upper Pin */
			       LCD_DATA_REG_OP &= 0x0F ;
     a42:	9b b3       	in	r25, 0x1b	; 27
     a44:	9f 70       	andi	r25, 0x0F	; 15
     a46:	9b bb       	out	0x1b, r25	; 27
			       LCD_DATA_REG_OP |= ((instruction << 4) & 0xF0);
     a48:	9b b3       	in	r25, 0x1b	; 27
     a4a:	82 95       	swap	r24
     a4c:	80 7f       	andi	r24, 0xF0	; 240
     a4e:	89 2b       	or	r24, r25
     a50:	8b bb       	out	0x1b, r24	; 27
     a52:	8f e9       	ldi	r24, 0x9F	; 159
     a54:	9f e0       	ldi	r25, 0x0F	; 15
     a56:	01 97       	sbiw	r24, 0x01	; 1
     a58:	f1 f7       	brne	.-4      	; 0xa56 <Send_instruction+0x6a>
     a5a:	00 c0       	rjmp	.+0      	; 0xa5c <Send_instruction+0x70>
     a5c:	00 00       	nop
		     	   LCD_DATA_REG_OP |= (instruction & 0x0F);  
            #endif
			/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
			_delay_ms(1);
			/* disable LCD E=0 */
			RESET_Bit(LCD_CONTROL_REG_OP,E);
     a5e:	da 98       	cbi	0x1b, 2	; 27
     a60:	ef e9       	ldi	r30, 0x9F	; 159
     a62:	ff e0       	ldi	r31, 0x0F	; 15
     a64:	31 97       	sbiw	r30, 0x01	; 1
     a66:	f1 f7       	brne	.-4      	; 0xa64 <Send_instruction+0x78>
     a68:	00 c0       	rjmp	.+0      	; 0xa6a <Send_instruction+0x7e>
     a6a:	00 00       	nop
			/* Data Hold delay Th = 10ns This In The Ideal State*/
			_delay_ms(1);
			#endif
	}	
     a6c:	08 95       	ret

00000a6e <LCD_init>:
		/* Set The Direction Of The 8 Data Bit As Output */
		LCD_DATA_REG_DIR = 0xFF;
		#else
		#ifdef LCD_UPPER_DATA_PORT
		/* Set The Direction Of The Higher 4 Data Bit As Output */
		LCD_DATA_REG_DIR |= 0xF0;
     a6e:	8a b3       	in	r24, 0x1a	; 26
     a70:	80 6f       	ori	r24, 0xF0	; 240
     a72:	8a bb       	out	0x1a, r24	; 26
		#else
		/* Set The Direction Of The Lower 4 Data Bit As Output */
		LCD_DATA_REG_DIR |= 0x0F;
		#endif
		/* Setup The Control Pin As A Output Pin */
		LCD_CONTROL_REG_DIR |= (1 << E) | (1 << RS) | (1 << RW);
     a74:	8a b3       	in	r24, 0x1a	; 26
     a76:	87 60       	ori	r24, 0x07	; 7
     a78:	8a bb       	out	0x1a, r24	; 26
		
		
			 /* Set LCD to Use 4 bits Op */
			 Send_instruction(RETURN_HOME);
     a7a:	82 e0       	ldi	r24, 0x02	; 2
     a7c:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
	   #endif
	   Send_instruction(FUNCTION_SET);
     a80:	88 e2       	ldi	r24, 0x28	; 40
     a82:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
	   Send_instruction(DISPLAY_ON);
     a86:	8c e0       	ldi	r24, 0x0C	; 12
     a88:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
	   Send_instruction(CLEAR_DISPALY);
     a8c:	81 e0       	ldi	r24, 0x01	; 1
     a8e:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
		
	}
     a92:	08 95       	ret

00000a94 <LCD_Clear>:
	
			
    void LCD_Clear(void)
	{
		/* Clear Instruction */
		Send_instruction(CLEAR_DISPALY);
     a94:	81 e0       	ldi	r24, 0x01	; 1
     a96:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
	}	
     a9a:	08 95       	ret

00000a9c <LCD_DisplayChar>:
	
		
    void LCD_DisplayChar(unsigned char Data)
	{
		/* The RS  Must Be RESET and The RW must be SET When Send Data To The LCD */
		SET_Bit(LCD_CONTROL_REG_OP, RS);
     a9c:	d8 9a       	sbi	0x1b, 0	; 27
		RESET_Bit(LCD_CONTROL_REG_OP, RW);
     a9e:	d9 98       	cbi	0x1b, 1	; 27
     aa0:	ef e9       	ldi	r30, 0x9F	; 159
     aa2:	ff e0       	ldi	r31, 0x0F	; 15
     aa4:	31 97       	sbiw	r30, 0x01	; 1
     aa6:	f1 f7       	brne	.-4      	; 0xaa4 <LCD_DisplayChar+0x8>
     aa8:	00 c0       	rjmp	.+0      	; 0xaaa <LCD_DisplayChar+0xe>
     aaa:	00 00       	nop
		/* Delay of Address Set 60ns minimum This In The Ideal State */
		_delay_ms(1);
		/* We WriteTo the LCD InThe Falling Of The Enable Pin */
		/* Set The Enable Pin */
		SET_Bit(LCD_CONTROL_REG_OP, E);
     aac:	da 9a       	sbi	0x1b, 2	; 27
     aae:	ef e9       	ldi	r30, 0x9F	; 159
     ab0:	ff e0       	ldi	r31, 0x0F	; 15
     ab2:	31 97       	sbiw	r30, 0x01	; 1
     ab4:	f1 f7       	brne	.-4      	; 0xab2 <LCD_DisplayChar+0x16>
     ab6:	00 c0       	rjmp	.+0      	; 0xab8 <LCD_DisplayChar+0x1c>
     ab8:	00 00       	nop
		
		#else
		/* At The First We Send The MSB 4-bit Of The Instruction So We handle If The User Connect LCD in The Upper Or Lower Pin Of The Port */
		#ifdef LCD_UPPER_DATA_PORT
		/* Setup The Data Port To hold The Data By Reset the Upper Pin */
		LCD_DATA_REG_OP &= 0x0F ;
     aba:	9b b3       	in	r25, 0x1b	; 27
     abc:	9f 70       	andi	r25, 0x0F	; 15
     abe:	9b bb       	out	0x1b, r25	; 27
		LCD_DATA_REG_OP |= (Data & 0xF0);
     ac0:	2b b3       	in	r18, 0x1b	; 27
     ac2:	98 2f       	mov	r25, r24
     ac4:	90 7f       	andi	r25, 0xF0	; 240
     ac6:	92 2b       	or	r25, r18
     ac8:	9b bb       	out	0x1b, r25	; 27
     aca:	ef e9       	ldi	r30, 0x9F	; 159
     acc:	ff e0       	ldi	r31, 0x0F	; 15
     ace:	31 97       	sbiw	r30, 0x01	; 1
     ad0:	f1 f7       	brne	.-4      	; 0xace <LCD_DisplayChar+0x32>
     ad2:	00 c0       	rjmp	.+0      	; 0xad4 <LCD_DisplayChar+0x38>
     ad4:	00 00       	nop
		
		/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
		_delay_ms(1);
		
		/* disable LCD E=0 */
		RESET_Bit(LCD_CONTROL_REG_OP,E);
     ad6:	da 98       	cbi	0x1b, 2	; 27
     ad8:	ef e9       	ldi	r30, 0x9F	; 159
     ada:	ff e0       	ldi	r31, 0x0F	; 15
     adc:	31 97       	sbiw	r30, 0x01	; 1
     ade:	f1 f7       	brne	.-4      	; 0xadc <LCD_DisplayChar+0x40>
     ae0:	00 c0       	rjmp	.+0      	; 0xae2 <LCD_DisplayChar+0x46>
     ae2:	00 00       	nop
		/* Data Hold delay Th = 10ns */
		_delay_ms(1);
		
		/* Reconfigure The E Pin To Prepare To Send The Next 4-bit LSB */
		SET_Bit(LCD_CONTROL_REG_OP, E);
     ae4:	da 9a       	sbi	0x1b, 2	; 27
     ae6:	ef e9       	ldi	r30, 0x9F	; 159
     ae8:	ff e0       	ldi	r31, 0x0F	; 15
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	f1 f7       	brne	.-4      	; 0xaea <LCD_DisplayChar+0x4e>
     aee:	00 c0       	rjmp	.+0      	; 0xaf0 <LCD_DisplayChar+0x54>
     af0:	00 00       	nop
		/* delay for processing PW min 450ns This In The Ideal State */
		_delay_ms(1);
		
		#ifdef LCD_UPPER_DATA_PORT
		/* Setup The Data Port To hold The Data By Reset the Upper Pin */
		LCD_DATA_REG_OP &= 0x0F ;
     af2:	9b b3       	in	r25, 0x1b	; 27
     af4:	9f 70       	andi	r25, 0x0F	; 15
     af6:	9b bb       	out	0x1b, r25	; 27
		LCD_DATA_REG_OP |= ((Data << 4) & 0xF0);
     af8:	9b b3       	in	r25, 0x1b	; 27
     afa:	82 95       	swap	r24
     afc:	80 7f       	andi	r24, 0xF0	; 240
     afe:	89 2b       	or	r24, r25
     b00:	8b bb       	out	0x1b, r24	; 27
     b02:	8f e9       	ldi	r24, 0x9F	; 159
     b04:	9f e0       	ldi	r25, 0x0F	; 15
     b06:	01 97       	sbiw	r24, 0x01	; 1
     b08:	f1 f7       	brne	.-4      	; 0xb06 <LCD_DisplayChar+0x6a>
     b0a:	00 c0       	rjmp	.+0      	; 0xb0c <LCD_DisplayChar+0x70>
     b0c:	00 00       	nop
		LCD_DATA_REG_OP |= (Data & 0x0F);
		#endif
		/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
		_delay_ms(1);
		/* disable LCD E=0 */
		RESET_Bit(LCD_CONTROL_REG_OP,E);
     b0e:	da 98       	cbi	0x1b, 2	; 27
     b10:	ef e9       	ldi	r30, 0x9F	; 159
     b12:	ff e0       	ldi	r31, 0x0F	; 15
     b14:	31 97       	sbiw	r30, 0x01	; 1
     b16:	f1 f7       	brne	.-4      	; 0xb14 <LCD_DisplayChar+0x78>
     b18:	00 c0       	rjmp	.+0      	; 0xb1a <LCD_DisplayChar+0x7e>
     b1a:	00 00       	nop
		/* Data Hold delay Th = 10ns This In The Ideal State*/
		_delay_ms(1);
		#endif
	}	
     b1c:	08 95       	ret

00000b1e <LCD_DisplayString>:
	
	
		
    void LCD_DisplayString(char * ptr)
	{
     b1e:	cf 93       	push	r28
     b20:	df 93       	push	r29
     b22:	ec 01       	movw	r28, r24
		while(*ptr != '\0')
     b24:	88 81       	ld	r24, Y
     b26:	88 23       	and	r24, r24
     b28:	31 f0       	breq	.+12     	; 0xb36 <LCD_DisplayString+0x18>
		#endif
	}	
	
	
		
    void LCD_DisplayString(char * ptr)
     b2a:	21 96       	adiw	r28, 0x01	; 1
	{
		while(*ptr != '\0')
		{
			LCD_DisplayChar(*ptr);
     b2c:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
	
	
		
    void LCD_DisplayString(char * ptr)
	{
		while(*ptr != '\0')
     b30:	89 91       	ld	r24, Y+
     b32:	88 23       	and	r24, r24
     b34:	d9 f7       	brne	.-10     	; 0xb2c <LCD_DisplayString+0xe>
		{
			LCD_DisplayChar(*ptr);
			ptr++;
		}
	}
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	08 95       	ret

00000b3c <LCD_Select_RowCol>:
	
			
    void LCD_Select_RowCol(unsigned char Row , unsigned char col)
	{
		char ADDRESS = 0x00;
		switch(Row)
     b3c:	81 30       	cpi	r24, 0x01	; 1
     b3e:	a1 f0       	breq	.+40     	; 0xb68 <LCD_Select_RowCol+0x2c>
     b40:	81 30       	cpi	r24, 0x01	; 1
     b42:	28 f4       	brcc	.+10     	; 0xb4e <LCD_Select_RowCol+0x12>
     b44:	86 2f       	mov	r24, r22
     b46:	80 68       	ori	r24, 0x80	; 128
			       ADDRESS= col | LCD_4TH_ROW;
			       break;
		}
		/* Form The Data Sheet it must Set The Bit 7 Before Send The Address */
		(ADDRESS) |= (1<<7);
		Send_instruction(ADDRESS);
     b48:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
	}
     b4c:	08 95       	ret
	
			
    void LCD_Select_RowCol(unsigned char Row , unsigned char col)
	{
		char ADDRESS = 0x00;
		switch(Row)
     b4e:	82 30       	cpi	r24, 0x02	; 2
     b50:	81 f0       	breq	.+32     	; 0xb72 <LCD_Select_RowCol+0x36>
     b52:	83 30       	cpi	r24, 0x03	; 3
     b54:	21 f0       	breq	.+8      	; 0xb5e <LCD_Select_RowCol+0x22>
     b56:	80 e8       	ldi	r24, 0x80	; 128
			       ADDRESS= col | LCD_4TH_ROW;
			       break;
		}
		/* Form The Data Sheet it must Set The Bit 7 Before Send The Address */
		(ADDRESS) |= (1<<7);
		Send_instruction(ADDRESS);
     b58:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
	}
     b5c:	08 95       	ret
			      ADDRESS= col | LCD_2ND_ROW;
			      break;
			case 2:
			       /* When Writing To LCD 1st Col The Base Address is 0x10 */
			       ADDRESS= col | LCD_3RD_ROW;
			       break;
     b5e:	86 2f       	mov	r24, r22
     b60:	80 6d       	ori	r24, 0xD0	; 208
			       ADDRESS= col | LCD_4TH_ROW;
			       break;
		}
		/* Form The Data Sheet it must Set The Bit 7 Before Send The Address */
		(ADDRESS) |= (1<<7);
		Send_instruction(ADDRESS);
     b62:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
	}
     b66:	08 95       	ret
		switch(Row)
		{
			case 0: 
			       /* When Writing To LCD 1st Col The Base Address is 0x00 */
			       ADDRESS= col | LCD_1ST_ROW;
			       break;
     b68:	86 2f       	mov	r24, r22
     b6a:	80 6c       	ori	r24, 0xC0	; 192
			       ADDRESS= col | LCD_4TH_ROW;
			       break;
		}
		/* Form The Data Sheet it must Set The Bit 7 Before Send The Address */
		(ADDRESS) |= (1<<7);
		Send_instruction(ADDRESS);
     b6c:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
	}
     b70:	08 95       	ret
			       ADDRESS= col | LCD_1ST_ROW;
			       break;
			case 1:
			      /* When Writing To LCD 1st Col The Base Address is 0x40 */
			      ADDRESS= col | LCD_2ND_ROW;
			      break;
     b72:	86 2f       	mov	r24, r22
     b74:	80 69       	ori	r24, 0x90	; 144
			       ADDRESS= col | LCD_4TH_ROW;
			       break;
		}
		/* Form The Data Sheet it must Set The Bit 7 Before Send The Address */
		(ADDRESS) |= (1<<7);
		Send_instruction(ADDRESS);
     b76:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
	}
     b7a:	08 95       	ret

00000b7c <LCD_DisplayInt>:
			
    void LCD_DisplayInt(long int data)
	{
     b7c:	0f 93       	push	r16
     b7e:	1f 93       	push	r17
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	cd b7       	in	r28, 0x3d	; 61
     b86:	de b7       	in	r29, 0x3e	; 62
     b88:	65 97       	sbiw	r28, 0x15	; 21
     b8a:	0f b6       	in	r0, 0x3f	; 63
     b8c:	f8 94       	cli
     b8e:	de bf       	out	0x3e, r29	; 62
     b90:	0f be       	out	0x3f, r0	; 63
     b92:	cd bf       	out	0x3d, r28	; 61
     b94:	dc 01       	movw	r26, r24
     b96:	cb 01       	movw	r24, r22
		/* String to hold the ASCI result */
		char Result[21];
		/* 10 for decimal */
		utoa(data,Result,10);
     b98:	be 01       	movw	r22, r28
     b9a:	6f 5f       	subi	r22, 0xFF	; 255
     b9c:	7f 4f       	sbci	r23, 0xFF	; 255
     b9e:	4a e0       	ldi	r20, 0x0A	; 10
     ba0:	50 e0       	ldi	r21, 0x00	; 0
     ba2:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <utoa>
	
	
		
    void LCD_DisplayString(char * ptr)
	{
		while(*ptr != '\0')
     ba6:	89 81       	ldd	r24, Y+1	; 0x01
     ba8:	88 23       	and	r24, r24
     baa:	51 f0       	breq	.+20     	; 0xbc0 <LCD_DisplayInt+0x44>
     bac:	8e 01       	movw	r16, r28
     bae:	0e 5f       	subi	r16, 0xFE	; 254
     bb0:	1f 4f       	sbci	r17, 0xFF	; 255
		{
			LCD_DisplayChar(*ptr);
     bb2:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
	
	
		
    void LCD_DisplayString(char * ptr)
	{
		while(*ptr != '\0')
     bb6:	f8 01       	movw	r30, r16
     bb8:	81 91       	ld	r24, Z+
     bba:	8f 01       	movw	r16, r30
     bbc:	88 23       	and	r24, r24
     bbe:	c9 f7       	brne	.-14     	; 0xbb2 <LCD_DisplayInt+0x36>
		char Result[21];
		/* 10 for decimal */
		utoa(data,Result,10);
		/* Display The Result */
		LCD_DisplayString(Result);
	} 
     bc0:	65 96       	adiw	r28, 0x15	; 21
     bc2:	0f b6       	in	r0, 0x3f	; 63
     bc4:	f8 94       	cli
     bc6:	de bf       	out	0x3e, r29	; 62
     bc8:	0f be       	out	0x3f, r0	; 63
     bca:	cd bf       	out	0x3d, r28	; 61
     bcc:	df 91       	pop	r29
     bce:	cf 91       	pop	r28
     bd0:	1f 91       	pop	r17
     bd2:	0f 91       	pop	r16
     bd4:	08 95       	ret

00000bd6 <LCD_StoreCustomchar>:
	
	void LCD_StoreCustomchar(unsigned char*pattern,unsigned char CGRAM_index)
	{
     bd6:	cf 93       	push	r28
     bd8:	df 93       	push	r29
     bda:	ec 01       	movw	r28, r24
		char ADDRESS = 0x00;
		char index;
		if (CGRAM_index < MAX_NWCHAR)
     bdc:	68 30       	cpi	r22, 0x08	; 8
     bde:	f8 f4       	brcc	.+62     	; 0xc1e <LCD_StoreCustomchar+0x48>
		{
			/* We Need To Move AC To Make it Point To The CGRAM at The Address Config By The User */
			ADDRESS = CGRAM_index;
			ADDRESS |= CGRAM_CONST; /* To Set The Bit Number 6 To point On The CGRAM Address Get From Datasheet */
			Send_instruction(ADDRESS);
     be0:	86 2f       	mov	r24, r22
     be2:	80 64       	ori	r24, 0x40	; 64
     be4:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
			/* Note That The AC increase Automatically After Write On The Address It Point To */
			for (index = 0; index < 8; index++)
			{
				LCD_DisplayChar(pattern[index]);
     be8:	88 81       	ld	r24, Y
     bea:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
     bf4:	8a 81       	ldd	r24, Y+2	; 0x02
     bf6:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
     bfa:	8b 81       	ldd	r24, Y+3	; 0x03
     bfc:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
     c00:	8c 81       	ldd	r24, Y+4	; 0x04
     c02:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
     c06:	8d 81       	ldd	r24, Y+5	; 0x05
     c08:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
     c0c:	8e 81       	ldd	r24, Y+6	; 0x06
     c0e:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
     c12:	8f 81       	ldd	r24, Y+7	; 0x07
     c14:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
			}
			/* We Need To Return The AC to point To The DDRAM */
			Send_instruction(RETURN_HOME);
     c18:	82 e0       	ldi	r24, 0x02	; 2
     c1a:	0e 94 f6 04 	call	0x9ec	; 0x9ec <Send_instruction>
		}
	}   
     c1e:	df 91       	pop	r29
     c20:	cf 91       	pop	r28
     c22:	08 95       	ret

00000c24 <RealTime_ClK_INTIA>:
  SevenSegment pins_7Segment=  {GPIOD, PIN0, PIN1, PIN2, PIN3};

		  
 
  void RealTime_ClK_INTIA(void)
  {
     c24:	0f 93       	push	r16
     c26:	1f 93       	push	r17
	  /* setup the pins and initiate the function for the LCD */
	  LCD_init();
     c28:	0e 94 37 05 	call	0xa6e	; 0xa6e <LCD_init>
	  
	  /* setup the pins for the Keypad */
	  keypad_Intiat(key);
     c2c:	00 91 df 00 	lds	r16, 0x00DF
     c30:	10 91 e0 00 	lds	r17, 0x00E0
     c34:	20 91 e1 00 	lds	r18, 0x00E1
     c38:	30 91 e2 00 	lds	r19, 0x00E2
     c3c:	40 91 e3 00 	lds	r20, 0x00E3
     c40:	50 91 e4 00 	lds	r21, 0x00E4
     c44:	60 91 e5 00 	lds	r22, 0x00E5
     c48:	70 91 e6 00 	lds	r23, 0x00E6
     c4c:	80 91 e7 00 	lds	r24, 0x00E7
     c50:	90 91 e8 00 	lds	r25, 0x00E8
     c54:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <keypad_Intiat>
	  
	  /* setup the pins for the 7-Segment */
	  sevenSegment_setup(pins_7Segment);
     c58:	40 91 c1 00 	lds	r20, 0x00C1
     c5c:	50 91 c2 00 	lds	r21, 0x00C2
     c60:	60 91 c3 00 	lds	r22, 0x00C3
     c64:	70 91 c4 00 	lds	r23, 0x00C4
     c68:	80 91 c5 00 	lds	r24, 0x00C5
     c6c:	90 91 c6 00 	lds	r25, 0x00C6
     c70:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <sevenSegment_setup>

	  
	  /* set up the enable pin for the each one of the 7-segment we make it Output pin the default value out is 0 if we change to 1 that enable the 7-segment */
	  DIO_pinConfiguration(GPIOC,En1_7SegHr, Output);
     c74:	83 e3       	ldi	r24, 0x33	; 51
     c76:	90 e0       	ldi	r25, 0x00	; 0
     c78:	60 e0       	ldi	r22, 0x00	; 0
     c7a:	42 e0       	ldi	r20, 0x02	; 2
     c7c:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	  DIO_pinConfiguration(GPIOC,En2_7SegHr, Output);
     c80:	83 e3       	ldi	r24, 0x33	; 51
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	61 e0       	ldi	r22, 0x01	; 1
     c86:	42 e0       	ldi	r20, 0x02	; 2
     c88:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	  DIO_pinConfiguration(GPIOC,En3_7SegMin, Output);
     c8c:	83 e3       	ldi	r24, 0x33	; 51
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	62 e0       	ldi	r22, 0x02	; 2
     c92:	42 e0       	ldi	r20, 0x02	; 2
     c94:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	  DIO_pinConfiguration(GPIOC,En4_7SegMin, Output);
     c98:	83 e3       	ldi	r24, 0x33	; 51
     c9a:	90 e0       	ldi	r25, 0x00	; 0
     c9c:	63 e0       	ldi	r22, 0x03	; 3
     c9e:	42 e0       	ldi	r20, 0x02	; 2
     ca0:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	  DIO_pinConfiguration(GPIOC,En5_7Segsec, Output);
     ca4:	83 e3       	ldi	r24, 0x33	; 51
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	64 e0       	ldi	r22, 0x04	; 4
     caa:	42 e0       	ldi	r20, 0x02	; 2
     cac:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	  DIO_pinConfiguration(GPIOC,En6_7Segsec, Output);
     cb0:	83 e3       	ldi	r24, 0x33	; 51
     cb2:	90 e0       	ldi	r25, 0x00	; 0
     cb4:	65 e0       	ldi	r22, 0x05	; 5
     cb6:	42 e0       	ldi	r20, 0x02	; 2
     cb8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_pinConfiguration>
	  
	  /* Timer 0 and 2 set up */
	  TIMER_INTIATE(timer0);
     cbc:	60 91 cb 00 	lds	r22, 0x00CB
     cc0:	70 91 cc 00 	lds	r23, 0x00CC
     cc4:	80 91 cd 00 	lds	r24, 0x00CD
     cc8:	90 91 ce 00 	lds	r25, 0x00CE
     ccc:	0e 94 70 01 	call	0x2e0	; 0x2e0 <TIMER_INTIATE>
	  TIMER_DELAY(timer0,CTC_TOP_VALUE);
     cd0:	60 91 cb 00 	lds	r22, 0x00CB
     cd4:	70 91 cc 00 	lds	r23, 0x00CC
     cd8:	80 91 cd 00 	lds	r24, 0x00CD
     cdc:	90 91 ce 00 	lds	r25, 0x00CE
     ce0:	4f e2       	ldi	r20, 0x2F	; 47
     ce2:	0e 94 07 02 	call	0x40e	; 0x40e <TIMER_DELAY>
	  TIMER_INTIATE(timer2);
     ce6:	60 91 c7 00 	lds	r22, 0x00C7
     cea:	70 91 c8 00 	lds	r23, 0x00C8
     cee:	80 91 c9 00 	lds	r24, 0x00C9
     cf2:	90 91 ca 00 	lds	r25, 0x00CA
     cf6:	0e 94 70 01 	call	0x2e0	; 0x2e0 <TIMER_INTIATE>
	  LCD_DisplayString("to setup Clock");
     cfa:	88 e6       	ldi	r24, 0x68	; 104
     cfc:	90 e0       	ldi	r25, 0x00	; 0
     cfe:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
	  LCD_Select_RowCol(1,3);
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	63 e0       	ldi	r22, 0x03	; 3
     d06:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	  LCD_DisplayString("press '1'");
     d0a:	87 e7       	ldi	r24, 0x77	; 119
     d0c:	90 e0       	ldi	r25, 0x00	; 0
     d0e:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
  }
     d12:	1f 91       	pop	r17
     d14:	0f 91       	pop	r16
     d16:	08 95       	ret

00000d18 <RealTime_ClK_OPERATE>:
  
  
  
  
  void RealTime_ClK_OPERATE(void)
  {
     d18:	0f 93       	push	r16
     d1a:	1f 93       	push	r17
     d1c:	cf 93       	push	r28
			DIO_pinWrite(GPIOC,En2_7SegHr,LOW);
			DIO_pinWrite(GPIOC,En3_7SegMin,LOW);
			DIO_pinWrite(GPIOC,En4_7SegMin,LOW);
			DIO_pinWrite(GPIOC,En5_7Segsec,LOW);
			DIO_pinWrite(GPIOC,En6_7Segsec,HIGH);
			sevenSegment_write(pins_7Segment, (oneSec_Counter%10));
     d1e:	ca e0       	ldi	r28, 0x0A	; 10
  
  
  
  void RealTime_ClK_OPERATE(void)
  {
	  while (keypad_Read(key) != '1')
     d20:	00 91 df 00 	lds	r16, 0x00DF
     d24:	10 91 e0 00 	lds	r17, 0x00E0
     d28:	20 91 e1 00 	lds	r18, 0x00E1
     d2c:	30 91 e2 00 	lds	r19, 0x00E2
     d30:	40 91 e3 00 	lds	r20, 0x00E3
     d34:	50 91 e4 00 	lds	r21, 0x00E4
     d38:	60 91 e5 00 	lds	r22, 0x00E5
     d3c:	70 91 e6 00 	lds	r23, 0x00E6
     d40:	80 91 e7 00 	lds	r24, 0x00E7
     d44:	90 91 e8 00 	lds	r25, 0x00E8
     d48:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
     d4c:	81 33       	cpi	r24, 0x31	; 49
     d4e:	09 f4       	brne	.+2      	; 0xd52 <RealTime_ClK_OPERATE+0x3a>
     d50:	94 c1       	rjmp	.+808    	; 0x107a <RealTime_ClK_OPERATE+0x362>
	  {
			DIO_pinWrite(GPIOC,En1_7SegHr,LOW);
     d52:	83 e3       	ldi	r24, 0x33	; 51
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	60 e0       	ldi	r22, 0x00	; 0
     d58:	40 e0       	ldi	r20, 0x00	; 0
     d5a:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En2_7SegHr,LOW);
     d5e:	83 e3       	ldi	r24, 0x33	; 51
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	61 e0       	ldi	r22, 0x01	; 1
     d64:	40 e0       	ldi	r20, 0x00	; 0
     d66:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En3_7SegMin,LOW);
     d6a:	83 e3       	ldi	r24, 0x33	; 51
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	62 e0       	ldi	r22, 0x02	; 2
     d70:	40 e0       	ldi	r20, 0x00	; 0
     d72:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En4_7SegMin,LOW);
     d76:	83 e3       	ldi	r24, 0x33	; 51
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	63 e0       	ldi	r22, 0x03	; 3
     d7c:	40 e0       	ldi	r20, 0x00	; 0
     d7e:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En5_7Segsec,LOW);
     d82:	83 e3       	ldi	r24, 0x33	; 51
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	64 e0       	ldi	r22, 0x04	; 4
     d88:	40 e0       	ldi	r20, 0x00	; 0
     d8a:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En6_7Segsec,HIGH);
     d8e:	83 e3       	ldi	r24, 0x33	; 51
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	65 e0       	ldi	r22, 0x05	; 5
     d94:	41 e0       	ldi	r20, 0x01	; 1
     d96:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			sevenSegment_write(pins_7Segment, (oneSec_Counter%10));
     d9a:	80 91 f1 00 	lds	r24, 0x00F1
     d9e:	6c 2f       	mov	r22, r28
     da0:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__udivmodqi4>
     da4:	29 2f       	mov	r18, r25
     da6:	40 91 c1 00 	lds	r20, 0x00C1
     daa:	50 91 c2 00 	lds	r21, 0x00C2
     dae:	60 91 c3 00 	lds	r22, 0x00C3
     db2:	70 91 c4 00 	lds	r23, 0x00C4
     db6:	80 91 c5 00 	lds	r24, 0x00C5
     dba:	90 91 c6 00 	lds	r25, 0x00C6
     dbe:	0e 94 0b 03 	call	0x616	; 0x616 <sevenSegment_write>
			Five_msec = 0;
     dc2:	10 92 f0 00 	sts	0x00F0, r1
			while(Five_msec == 0);
     dc6:	80 91 f0 00 	lds	r24, 0x00F0
     dca:	88 23       	and	r24, r24
     dcc:	e1 f3       	breq	.-8      	; 0xdc6 <RealTime_ClK_OPERATE+0xae>
			DIO_pinWrite(GPIOC,En1_7SegHr,LOW);
     dce:	83 e3       	ldi	r24, 0x33	; 51
     dd0:	90 e0       	ldi	r25, 0x00	; 0
     dd2:	60 e0       	ldi	r22, 0x00	; 0
     dd4:	40 e0       	ldi	r20, 0x00	; 0
     dd6:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En2_7SegHr,LOW);
     dda:	83 e3       	ldi	r24, 0x33	; 51
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	61 e0       	ldi	r22, 0x01	; 1
     de0:	40 e0       	ldi	r20, 0x00	; 0
     de2:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En3_7SegMin,LOW);
     de6:	83 e3       	ldi	r24, 0x33	; 51
     de8:	90 e0       	ldi	r25, 0x00	; 0
     dea:	62 e0       	ldi	r22, 0x02	; 2
     dec:	40 e0       	ldi	r20, 0x00	; 0
     dee:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En4_7SegMin,LOW);
     df2:	83 e3       	ldi	r24, 0x33	; 51
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	63 e0       	ldi	r22, 0x03	; 3
     df8:	40 e0       	ldi	r20, 0x00	; 0
     dfa:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En5_7Segsec,HIGH);
     dfe:	83 e3       	ldi	r24, 0x33	; 51
     e00:	90 e0       	ldi	r25, 0x00	; 0
     e02:	64 e0       	ldi	r22, 0x04	; 4
     e04:	41 e0       	ldi	r20, 0x01	; 1
     e06:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			DIO_pinWrite(GPIOC,En6_7Segsec,LOW);
     e0a:	83 e3       	ldi	r24, 0x33	; 51
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	65 e0       	ldi	r22, 0x05	; 5
     e10:	40 e0       	ldi	r20, 0x00	; 0
     e12:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
			sevenSegment_write(pins_7Segment, (oneSec_Counter/10));
     e16:	80 91 f1 00 	lds	r24, 0x00F1
     e1a:	6c 2f       	mov	r22, r28
     e1c:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__udivmodqi4>
     e20:	28 2f       	mov	r18, r24
     e22:	40 91 c1 00 	lds	r20, 0x00C1
     e26:	50 91 c2 00 	lds	r21, 0x00C2
     e2a:	60 91 c3 00 	lds	r22, 0x00C3
     e2e:	70 91 c4 00 	lds	r23, 0x00C4
     e32:	80 91 c5 00 	lds	r24, 0x00C5
     e36:	90 91 c6 00 	lds	r25, 0x00C6
     e3a:	0e 94 0b 03 	call	0x616	; 0x616 <sevenSegment_write>
			Five_msec = 0;
     e3e:	10 92 f0 00 	sts	0x00F0, r1
			while(Five_msec == 0);
     e42:	80 91 f0 00 	lds	r24, 0x00F0
     e46:	88 23       	and	r24, r24
     e48:	e1 f3       	breq	.-8      	; 0xe42 <RealTime_ClK_OPERATE+0x12a>
			
		
		  	
        DIO_pinWrite(GPIOC,En1_7SegHr,LOW);
     e4a:	83 e3       	ldi	r24, 0x33	; 51
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	60 e0       	ldi	r22, 0x00	; 0
     e50:	40 e0       	ldi	r20, 0x00	; 0
     e52:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En2_7SegHr,LOW);
     e56:	83 e3       	ldi	r24, 0x33	; 51
     e58:	90 e0       	ldi	r25, 0x00	; 0
     e5a:	61 e0       	ldi	r22, 0x01	; 1
     e5c:	40 e0       	ldi	r20, 0x00	; 0
     e5e:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En3_7SegMin,LOW);
     e62:	83 e3       	ldi	r24, 0x33	; 51
     e64:	90 e0       	ldi	r25, 0x00	; 0
     e66:	62 e0       	ldi	r22, 0x02	; 2
     e68:	40 e0       	ldi	r20, 0x00	; 0
     e6a:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En4_7SegMin,HIGH);
     e6e:	83 e3       	ldi	r24, 0x33	; 51
     e70:	90 e0       	ldi	r25, 0x00	; 0
     e72:	63 e0       	ldi	r22, 0x03	; 3
     e74:	41 e0       	ldi	r20, 0x01	; 1
     e76:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En5_7Segsec,LOW);
     e7a:	83 e3       	ldi	r24, 0x33	; 51
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	64 e0       	ldi	r22, 0x04	; 4
     e80:	40 e0       	ldi	r20, 0x00	; 0
     e82:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En6_7Segsec,LOW);
     e86:	83 e3       	ldi	r24, 0x33	; 51
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	65 e0       	ldi	r22, 0x05	; 5
     e8c:	40 e0       	ldi	r20, 0x00	; 0
     e8e:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		sevenSegment_write(pins_7Segment, (oneMin_Counter%10));
     e92:	80 91 f3 00 	lds	r24, 0x00F3
     e96:	6c 2f       	mov	r22, r28
     e98:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__udivmodqi4>
     e9c:	29 2f       	mov	r18, r25
     e9e:	40 91 c1 00 	lds	r20, 0x00C1
     ea2:	50 91 c2 00 	lds	r21, 0x00C2
     ea6:	60 91 c3 00 	lds	r22, 0x00C3
     eaa:	70 91 c4 00 	lds	r23, 0x00C4
     eae:	80 91 c5 00 	lds	r24, 0x00C5
     eb2:	90 91 c6 00 	lds	r25, 0x00C6
     eb6:	0e 94 0b 03 	call	0x616	; 0x616 <sevenSegment_write>
		Five_msec = 0;
     eba:	10 92 f0 00 	sts	0x00F0, r1
		while(Five_msec == 0);
     ebe:	80 91 f0 00 	lds	r24, 0x00F0
     ec2:	88 23       	and	r24, r24
     ec4:	e1 f3       	breq	.-8      	; 0xebe <RealTime_ClK_OPERATE+0x1a6>
		DIO_pinWrite(GPIOC,En1_7SegHr,LOW);
     ec6:	83 e3       	ldi	r24, 0x33	; 51
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	60 e0       	ldi	r22, 0x00	; 0
     ecc:	40 e0       	ldi	r20, 0x00	; 0
     ece:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En2_7SegHr,LOW);
     ed2:	83 e3       	ldi	r24, 0x33	; 51
     ed4:	90 e0       	ldi	r25, 0x00	; 0
     ed6:	61 e0       	ldi	r22, 0x01	; 1
     ed8:	40 e0       	ldi	r20, 0x00	; 0
     eda:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En3_7SegMin,HIGH);
     ede:	83 e3       	ldi	r24, 0x33	; 51
     ee0:	90 e0       	ldi	r25, 0x00	; 0
     ee2:	62 e0       	ldi	r22, 0x02	; 2
     ee4:	41 e0       	ldi	r20, 0x01	; 1
     ee6:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En4_7SegMin,LOW);
     eea:	83 e3       	ldi	r24, 0x33	; 51
     eec:	90 e0       	ldi	r25, 0x00	; 0
     eee:	63 e0       	ldi	r22, 0x03	; 3
     ef0:	40 e0       	ldi	r20, 0x00	; 0
     ef2:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En5_7Segsec,LOW);
     ef6:	83 e3       	ldi	r24, 0x33	; 51
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	64 e0       	ldi	r22, 0x04	; 4
     efc:	40 e0       	ldi	r20, 0x00	; 0
     efe:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En6_7Segsec,LOW);
     f02:	83 e3       	ldi	r24, 0x33	; 51
     f04:	90 e0       	ldi	r25, 0x00	; 0
     f06:	65 e0       	ldi	r22, 0x05	; 5
     f08:	40 e0       	ldi	r20, 0x00	; 0
     f0a:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		sevenSegment_write(pins_7Segment, (oneMin_Counter/10));
     f0e:	80 91 f3 00 	lds	r24, 0x00F3
     f12:	6c 2f       	mov	r22, r28
     f14:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__udivmodqi4>
     f18:	28 2f       	mov	r18, r24
     f1a:	40 91 c1 00 	lds	r20, 0x00C1
     f1e:	50 91 c2 00 	lds	r21, 0x00C2
     f22:	60 91 c3 00 	lds	r22, 0x00C3
     f26:	70 91 c4 00 	lds	r23, 0x00C4
     f2a:	80 91 c5 00 	lds	r24, 0x00C5
     f2e:	90 91 c6 00 	lds	r25, 0x00C6
     f32:	0e 94 0b 03 	call	0x616	; 0x616 <sevenSegment_write>
		Five_msec = 0;
     f36:	10 92 f0 00 	sts	0x00F0, r1
		while(Five_msec == 0);
     f3a:	80 91 f0 00 	lds	r24, 0x00F0
     f3e:	88 23       	and	r24, r24
     f40:	e1 f3       	breq	.-8      	; 0xf3a <RealTime_ClK_OPERATE+0x222>
		
	
		DIO_pinWrite(GPIOC,En1_7SegHr,LOW);
     f42:	83 e3       	ldi	r24, 0x33	; 51
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	60 e0       	ldi	r22, 0x00	; 0
     f48:	40 e0       	ldi	r20, 0x00	; 0
     f4a:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En2_7SegHr,HIGH);
     f4e:	83 e3       	ldi	r24, 0x33	; 51
     f50:	90 e0       	ldi	r25, 0x00	; 0
     f52:	61 e0       	ldi	r22, 0x01	; 1
     f54:	41 e0       	ldi	r20, 0x01	; 1
     f56:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En3_7SegMin,LOW);
     f5a:	83 e3       	ldi	r24, 0x33	; 51
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	62 e0       	ldi	r22, 0x02	; 2
     f60:	40 e0       	ldi	r20, 0x00	; 0
     f62:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En4_7SegMin,LOW);
     f66:	83 e3       	ldi	r24, 0x33	; 51
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	63 e0       	ldi	r22, 0x03	; 3
     f6c:	40 e0       	ldi	r20, 0x00	; 0
     f6e:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En5_7Segsec,LOW);
     f72:	83 e3       	ldi	r24, 0x33	; 51
     f74:	90 e0       	ldi	r25, 0x00	; 0
     f76:	64 e0       	ldi	r22, 0x04	; 4
     f78:	40 e0       	ldi	r20, 0x00	; 0
     f7a:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En6_7Segsec,LOW);
     f7e:	83 e3       	ldi	r24, 0x33	; 51
     f80:	90 e0       	ldi	r25, 0x00	; 0
     f82:	65 e0       	ldi	r22, 0x05	; 5
     f84:	40 e0       	ldi	r20, 0x00	; 0
     f86:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		sevenSegment_write(pins_7Segment, (oneHr_Counter%10));
     f8a:	80 91 f4 00 	lds	r24, 0x00F4
     f8e:	6c 2f       	mov	r22, r28
     f90:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__udivmodqi4>
     f94:	29 2f       	mov	r18, r25
     f96:	40 91 c1 00 	lds	r20, 0x00C1
     f9a:	50 91 c2 00 	lds	r21, 0x00C2
     f9e:	60 91 c3 00 	lds	r22, 0x00C3
     fa2:	70 91 c4 00 	lds	r23, 0x00C4
     fa6:	80 91 c5 00 	lds	r24, 0x00C5
     faa:	90 91 c6 00 	lds	r25, 0x00C6
     fae:	0e 94 0b 03 	call	0x616	; 0x616 <sevenSegment_write>
		Five_msec = 0;
     fb2:	10 92 f0 00 	sts	0x00F0, r1
		while(Five_msec == 0);
     fb6:	80 91 f0 00 	lds	r24, 0x00F0
     fba:	88 23       	and	r24, r24
     fbc:	e1 f3       	breq	.-8      	; 0xfb6 <RealTime_ClK_OPERATE+0x29e>
		DIO_pinWrite(GPIOC,En1_7SegHr,HIGH);
     fbe:	83 e3       	ldi	r24, 0x33	; 51
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	60 e0       	ldi	r22, 0x00	; 0
     fc4:	41 e0       	ldi	r20, 0x01	; 1
     fc6:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En2_7SegHr,LOW);
     fca:	83 e3       	ldi	r24, 0x33	; 51
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	61 e0       	ldi	r22, 0x01	; 1
     fd0:	40 e0       	ldi	r20, 0x00	; 0
     fd2:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En3_7SegMin,LOW);
     fd6:	83 e3       	ldi	r24, 0x33	; 51
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	62 e0       	ldi	r22, 0x02	; 2
     fdc:	40 e0       	ldi	r20, 0x00	; 0
     fde:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En4_7SegMin,LOW);
     fe2:	83 e3       	ldi	r24, 0x33	; 51
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	63 e0       	ldi	r22, 0x03	; 3
     fe8:	40 e0       	ldi	r20, 0x00	; 0
     fea:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En5_7Segsec,LOW);
     fee:	83 e3       	ldi	r24, 0x33	; 51
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	64 e0       	ldi	r22, 0x04	; 4
     ff4:	40 e0       	ldi	r20, 0x00	; 0
     ff6:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		DIO_pinWrite(GPIOC,En6_7Segsec,LOW);
     ffa:	83 e3       	ldi	r24, 0x33	; 51
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	65 e0       	ldi	r22, 0x05	; 5
    1000:	40 e0       	ldi	r20, 0x00	; 0
    1002:	0e 94 7f 00 	call	0xfe	; 0xfe <DIO_pinWrite>
		sevenSegment_write(pins_7Segment, (oneHr_Counter/10));
    1006:	80 91 f4 00 	lds	r24, 0x00F4
    100a:	6c 2f       	mov	r22, r28
    100c:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__udivmodqi4>
    1010:	28 2f       	mov	r18, r24
    1012:	40 91 c1 00 	lds	r20, 0x00C1
    1016:	50 91 c2 00 	lds	r21, 0x00C2
    101a:	60 91 c3 00 	lds	r22, 0x00C3
    101e:	70 91 c4 00 	lds	r23, 0x00C4
    1022:	80 91 c5 00 	lds	r24, 0x00C5
    1026:	90 91 c6 00 	lds	r25, 0x00C6
    102a:	0e 94 0b 03 	call	0x616	; 0x616 <sevenSegment_write>
		Five_msec = 0;
    102e:	10 92 f0 00 	sts	0x00F0, r1
		while(Five_msec == 0);		  
    1032:	80 91 f0 00 	lds	r24, 0x00F0
    1036:	88 23       	and	r24, r24
    1038:	e1 f3       	breq	.-8      	; 0x1032 <RealTime_ClK_OPERATE+0x31a>
		  if (oneSec_Counter >= 60)
    103a:	80 91 f1 00 	lds	r24, 0x00F1
    103e:	8c 33       	cpi	r24, 0x3C	; 60
    1040:	a0 f4       	brcc	.+40     	; 0x106a <RealTime_ClK_OPERATE+0x352>
    1042:	80 91 f3 00 	lds	r24, 0x00F3
		  {
			  oneSec_Counter = 0;
			  oneMin_Counter++;
		  }
		  if (oneMin_Counter >= 60)
    1046:	8c 33       	cpi	r24, 0x3C	; 60
    1048:	40 f4       	brcc	.+16     	; 0x105a <RealTime_ClK_OPERATE+0x342>
    104a:	80 91 f4 00 	lds	r24, 0x00F4
		  {
			  oneMin_Counter = 0;
			  oneHr_Counter++;
		  }
		  if (oneHr_Counter >= 25)
    104e:	89 31       	cpi	r24, 0x19	; 25
    1050:	08 f4       	brcc	.+2      	; 0x1054 <RealTime_ClK_OPERATE+0x33c>
    1052:	66 ce       	rjmp	.-820    	; 0xd20 <RealTime_ClK_OPERATE+0x8>
		  {
			  oneHr_Counter =0;
    1054:	10 92 f4 00 	sts	0x00F4, r1
    1058:	63 ce       	rjmp	.-826    	; 0xd20 <RealTime_ClK_OPERATE+0x8>
			  oneSec_Counter = 0;
			  oneMin_Counter++;
		  }
		  if (oneMin_Counter >= 60)
		  {
			  oneMin_Counter = 0;
    105a:	10 92 f3 00 	sts	0x00F3, r1
			  oneHr_Counter++;
    105e:	80 91 f4 00 	lds	r24, 0x00F4
    1062:	8f 5f       	subi	r24, 0xFF	; 255
    1064:	80 93 f4 00 	sts	0x00F4, r24
    1068:	f2 cf       	rjmp	.-28     	; 0x104e <RealTime_ClK_OPERATE+0x336>
		sevenSegment_write(pins_7Segment, (oneHr_Counter/10));
		Five_msec = 0;
		while(Five_msec == 0);		  
		  if (oneSec_Counter >= 60)
		  {
			  oneSec_Counter = 0;
    106a:	10 92 f1 00 	sts	0x00F1, r1
			  oneMin_Counter++;
    106e:	80 91 f3 00 	lds	r24, 0x00F3
    1072:	8f 5f       	subi	r24, 0xFF	; 255
    1074:	80 93 f3 00 	sts	0x00F3, r24
    1078:	e6 cf       	rjmp	.-52     	; 0x1046 <RealTime_ClK_OPERATE+0x32e>
			  oneHr_Counter =0;
		  }
		  		  
		  		  
	  }
	  LCD_Clear();
    107a:	0e 94 4a 05 	call	0xa94	; 0xa94 <LCD_Clear>
	  LCD_DisplayString("Set Hour : _ _");
    107e:	81 e8       	ldi	r24, 0x81	; 129
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
	  LCD_Select_RowCol(0,11);
    1086:	80 e0       	ldi	r24, 0x00	; 0
    1088:	6b e0       	ldi	r22, 0x0B	; 11
    108a:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	  while(temp_var == 0)
    108e:	80 91 f2 00 	lds	r24, 0x00F2
    1092:	88 23       	and	r24, r24
    1094:	d1 f4       	brne	.+52     	; 0x10ca <RealTime_ClK_OPERATE+0x3b2>
	  {
	     temp_var = keypad_Read(key) ;
    1096:	00 91 df 00 	lds	r16, 0x00DF
    109a:	10 91 e0 00 	lds	r17, 0x00E0
    109e:	20 91 e1 00 	lds	r18, 0x00E1
    10a2:	30 91 e2 00 	lds	r19, 0x00E2
    10a6:	40 91 e3 00 	lds	r20, 0x00E3
    10aa:	50 91 e4 00 	lds	r21, 0x00E4
    10ae:	60 91 e5 00 	lds	r22, 0x00E5
    10b2:	70 91 e6 00 	lds	r23, 0x00E6
    10b6:	80 91 e7 00 	lds	r24, 0x00E7
    10ba:	90 91 e8 00 	lds	r25, 0x00E8
    10be:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
    10c2:	80 93 f2 00 	sts	0x00F2, r24
		  		  
	  }
	  LCD_Clear();
	  LCD_DisplayString("Set Hour : _ _");
	  LCD_Select_RowCol(0,11);
	  while(temp_var == 0)
    10c6:	88 23       	and	r24, r24
    10c8:	31 f3       	breq	.-52     	; 0x1096 <RealTime_ClK_OPERATE+0x37e>
	  {
	     temp_var = keypad_Read(key) ;
	  }	  
	  oneHr_Counter = ((temp_var - 48) * 10);
    10ca:	28 2f       	mov	r18, r24
    10cc:	22 0f       	add	r18, r18
    10ce:	92 2f       	mov	r25, r18
    10d0:	99 0f       	add	r25, r25
    10d2:	99 0f       	add	r25, r25
    10d4:	92 0f       	add	r25, r18
    10d6:	90 5e       	subi	r25, 0xE0	; 224
    10d8:	90 93 f4 00 	sts	0x00F4, r25
	  LCD_DisplayChar(temp_var);
    10dc:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
	  LCD_Select_RowCol(0,13);
    10e0:	80 e0       	ldi	r24, 0x00	; 0
    10e2:	6d e0       	ldi	r22, 0x0D	; 13
    10e4:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	  temp_var = 0 ;
    10e8:	10 92 f2 00 	sts	0x00F2, r1
	  while(temp_var == 0)
	  {
		  temp_var = keypad_Read(key);
    10ec:	00 91 df 00 	lds	r16, 0x00DF
    10f0:	10 91 e0 00 	lds	r17, 0x00E0
    10f4:	20 91 e1 00 	lds	r18, 0x00E1
    10f8:	30 91 e2 00 	lds	r19, 0x00E2
    10fc:	40 91 e3 00 	lds	r20, 0x00E3
    1100:	50 91 e4 00 	lds	r21, 0x00E4
    1104:	60 91 e5 00 	lds	r22, 0x00E5
    1108:	70 91 e6 00 	lds	r23, 0x00E6
    110c:	80 91 e7 00 	lds	r24, 0x00E7
    1110:	90 91 e8 00 	lds	r25, 0x00E8
    1114:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
    1118:	80 93 f2 00 	sts	0x00F2, r24
	  }	  
	  oneHr_Counter = ((temp_var - 48) * 10);
	  LCD_DisplayChar(temp_var);
	  LCD_Select_RowCol(0,13);
	  temp_var = 0 ;
	  while(temp_var == 0)
    111c:	88 23       	and	r24, r24
    111e:	31 f3       	breq	.-52     	; 0x10ec <RealTime_ClK_OPERATE+0x3d4>
	  {
		  temp_var = keypad_Read(key);
	  }
	  oneHr_Counter =oneHr_Counter + (temp_var - 48);
    1120:	90 91 f4 00 	lds	r25, 0x00F4
    1124:	90 53       	subi	r25, 0x30	; 48
    1126:	98 0f       	add	r25, r24
    1128:	90 93 f4 00 	sts	0x00F4, r25
	  LCD_DisplayChar(temp_var);
    112c:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
	  LCD_Select_RowCol(1,0);
    1130:	81 e0       	ldi	r24, 0x01	; 1
    1132:	60 e0       	ldi	r22, 0x00	; 0
    1134:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	   temp_var = 0 ;
    1138:	10 92 f2 00 	sts	0x00F2, r1
	  LCD_DisplayString("Next press '*'");
    113c:	80 e9       	ldi	r24, 0x90	; 144
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
	  while(keypad_Read(key) != '*');
    1144:	00 91 df 00 	lds	r16, 0x00DF
    1148:	10 91 e0 00 	lds	r17, 0x00E0
    114c:	20 91 e1 00 	lds	r18, 0x00E1
    1150:	30 91 e2 00 	lds	r19, 0x00E2
    1154:	40 91 e3 00 	lds	r20, 0x00E3
    1158:	50 91 e4 00 	lds	r21, 0x00E4
    115c:	60 91 e5 00 	lds	r22, 0x00E5
    1160:	70 91 e6 00 	lds	r23, 0x00E6
    1164:	80 91 e7 00 	lds	r24, 0x00E7
    1168:	90 91 e8 00 	lds	r25, 0x00E8
    116c:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
    1170:	8a 32       	cpi	r24, 0x2A	; 42
    1172:	41 f7       	brne	.-48     	; 0x1144 <RealTime_ClK_OPERATE+0x42c>
	  
	  /* Set Up the Minute */
	  LCD_Clear();
    1174:	0e 94 4a 05 	call	0xa94	; 0xa94 <LCD_Clear>
	  LCD_DisplayString("Set Minute : _ _");
    1178:	8f e9       	ldi	r24, 0x9F	; 159
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
	  LCD_Select_RowCol(0,13);
    1180:	80 e0       	ldi	r24, 0x00	; 0
    1182:	6d e0       	ldi	r22, 0x0D	; 13
    1184:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	  while(temp_var == 0)
    1188:	80 91 f2 00 	lds	r24, 0x00F2
    118c:	88 23       	and	r24, r24
    118e:	d1 f4       	brne	.+52     	; 0x11c4 <RealTime_ClK_OPERATE+0x4ac>
	  {
		  temp_var = keypad_Read(key) ;
    1190:	00 91 df 00 	lds	r16, 0x00DF
    1194:	10 91 e0 00 	lds	r17, 0x00E0
    1198:	20 91 e1 00 	lds	r18, 0x00E1
    119c:	30 91 e2 00 	lds	r19, 0x00E2
    11a0:	40 91 e3 00 	lds	r20, 0x00E3
    11a4:	50 91 e4 00 	lds	r21, 0x00E4
    11a8:	60 91 e5 00 	lds	r22, 0x00E5
    11ac:	70 91 e6 00 	lds	r23, 0x00E6
    11b0:	80 91 e7 00 	lds	r24, 0x00E7
    11b4:	90 91 e8 00 	lds	r25, 0x00E8
    11b8:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
    11bc:	80 93 f2 00 	sts	0x00F2, r24
	  
	  /* Set Up the Minute */
	  LCD_Clear();
	  LCD_DisplayString("Set Minute : _ _");
	  LCD_Select_RowCol(0,13);
	  while(temp_var == 0)
    11c0:	88 23       	and	r24, r24
    11c2:	31 f3       	breq	.-52     	; 0x1190 <RealTime_ClK_OPERATE+0x478>
	  {
		  temp_var = keypad_Read(key) ;
	  }
	  oneMin_Counter = ((temp_var - 48) * 10);
    11c4:	28 2f       	mov	r18, r24
    11c6:	22 0f       	add	r18, r18
    11c8:	92 2f       	mov	r25, r18
    11ca:	99 0f       	add	r25, r25
    11cc:	99 0f       	add	r25, r25
    11ce:	92 0f       	add	r25, r18
    11d0:	90 5e       	subi	r25, 0xE0	; 224
    11d2:	90 93 f3 00 	sts	0x00F3, r25
	  LCD_DisplayChar(temp_var);
    11d6:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
	  LCD_Select_RowCol(0,15);
    11da:	80 e0       	ldi	r24, 0x00	; 0
    11dc:	6f e0       	ldi	r22, 0x0F	; 15
    11de:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	  temp_var = 0 ;
    11e2:	10 92 f2 00 	sts	0x00F2, r1
	  while(temp_var == 0)
	  {
		  temp_var = keypad_Read(key);
    11e6:	00 91 df 00 	lds	r16, 0x00DF
    11ea:	10 91 e0 00 	lds	r17, 0x00E0
    11ee:	20 91 e1 00 	lds	r18, 0x00E1
    11f2:	30 91 e2 00 	lds	r19, 0x00E2
    11f6:	40 91 e3 00 	lds	r20, 0x00E3
    11fa:	50 91 e4 00 	lds	r21, 0x00E4
    11fe:	60 91 e5 00 	lds	r22, 0x00E5
    1202:	70 91 e6 00 	lds	r23, 0x00E6
    1206:	80 91 e7 00 	lds	r24, 0x00E7
    120a:	90 91 e8 00 	lds	r25, 0x00E8
    120e:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
    1212:	80 93 f2 00 	sts	0x00F2, r24
	  }
	  oneMin_Counter = ((temp_var - 48) * 10);
	  LCD_DisplayChar(temp_var);
	  LCD_Select_RowCol(0,15);
	  temp_var = 0 ;
	  while(temp_var == 0)
    1216:	88 23       	and	r24, r24
    1218:	31 f3       	breq	.-52     	; 0x11e6 <RealTime_ClK_OPERATE+0x4ce>
	  {
		  temp_var = keypad_Read(key);
	  }
	  oneMin_Counter =oneMin_Counter + (temp_var - 48);
    121a:	90 91 f3 00 	lds	r25, 0x00F3
    121e:	90 53       	subi	r25, 0x30	; 48
    1220:	98 0f       	add	r25, r24
    1222:	90 93 f3 00 	sts	0x00F3, r25
	  LCD_DisplayChar(temp_var);
    1226:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
	  LCD_Select_RowCol(1,0);
    122a:	81 e0       	ldi	r24, 0x01	; 1
    122c:	60 e0       	ldi	r22, 0x00	; 0
    122e:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	   temp_var = 0 ;
    1232:	10 92 f2 00 	sts	0x00F2, r1
	  LCD_DisplayString("Next press '*'");
    1236:	80 e9       	ldi	r24, 0x90	; 144
    1238:	90 e0       	ldi	r25, 0x00	; 0
    123a:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
	  while(keypad_Read(key) != '*');
    123e:	00 91 df 00 	lds	r16, 0x00DF
    1242:	10 91 e0 00 	lds	r17, 0x00E0
    1246:	20 91 e1 00 	lds	r18, 0x00E1
    124a:	30 91 e2 00 	lds	r19, 0x00E2
    124e:	40 91 e3 00 	lds	r20, 0x00E3
    1252:	50 91 e4 00 	lds	r21, 0x00E4
    1256:	60 91 e5 00 	lds	r22, 0x00E5
    125a:	70 91 e6 00 	lds	r23, 0x00E6
    125e:	80 91 e7 00 	lds	r24, 0x00E7
    1262:	90 91 e8 00 	lds	r25, 0x00E8
    1266:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
    126a:	8a 32       	cpi	r24, 0x2A	; 42
    126c:	41 f7       	brne	.-48     	; 0x123e <RealTime_ClK_OPERATE+0x526>
	  
	  /* Set Up the Second */
	  LCD_Clear();
    126e:	0e 94 4a 05 	call	0xa94	; 0xa94 <LCD_Clear>
	  LCD_DisplayString("Set Second : _ _");
    1272:	80 eb       	ldi	r24, 0xB0	; 176
    1274:	90 e0       	ldi	r25, 0x00	; 0
    1276:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
	  LCD_Select_RowCol(0,13);
    127a:	80 e0       	ldi	r24, 0x00	; 0
    127c:	6d e0       	ldi	r22, 0x0D	; 13
    127e:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	  while(temp_var == 0)
    1282:	80 91 f2 00 	lds	r24, 0x00F2
    1286:	88 23       	and	r24, r24
    1288:	d1 f4       	brne	.+52     	; 0x12be <RealTime_ClK_OPERATE+0x5a6>
	  {
		  temp_var = keypad_Read(key) ;
    128a:	00 91 df 00 	lds	r16, 0x00DF
    128e:	10 91 e0 00 	lds	r17, 0x00E0
    1292:	20 91 e1 00 	lds	r18, 0x00E1
    1296:	30 91 e2 00 	lds	r19, 0x00E2
    129a:	40 91 e3 00 	lds	r20, 0x00E3
    129e:	50 91 e4 00 	lds	r21, 0x00E4
    12a2:	60 91 e5 00 	lds	r22, 0x00E5
    12a6:	70 91 e6 00 	lds	r23, 0x00E6
    12aa:	80 91 e7 00 	lds	r24, 0x00E7
    12ae:	90 91 e8 00 	lds	r25, 0x00E8
    12b2:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
    12b6:	80 93 f2 00 	sts	0x00F2, r24
	  
	  /* Set Up the Second */
	  LCD_Clear();
	  LCD_DisplayString("Set Second : _ _");
	  LCD_Select_RowCol(0,13);
	  while(temp_var == 0)
    12ba:	88 23       	and	r24, r24
    12bc:	31 f3       	breq	.-52     	; 0x128a <RealTime_ClK_OPERATE+0x572>
	  {
		  temp_var = keypad_Read(key) ;
	  }
	  oneSec_Counter = ((temp_var - 48) * 10);
    12be:	28 2f       	mov	r18, r24
    12c0:	22 0f       	add	r18, r18
    12c2:	92 2f       	mov	r25, r18
    12c4:	99 0f       	add	r25, r25
    12c6:	99 0f       	add	r25, r25
    12c8:	92 0f       	add	r25, r18
    12ca:	90 5e       	subi	r25, 0xE0	; 224
    12cc:	90 93 f1 00 	sts	0x00F1, r25
	  LCD_DisplayChar(temp_var);
    12d0:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
	  LCD_Select_RowCol(0,15);
    12d4:	80 e0       	ldi	r24, 0x00	; 0
    12d6:	6f e0       	ldi	r22, 0x0F	; 15
    12d8:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	  temp_var = 0 ;
    12dc:	10 92 f2 00 	sts	0x00F2, r1
	  while(temp_var == 0)
	  {
		  temp_var = keypad_Read(key);
    12e0:	00 91 df 00 	lds	r16, 0x00DF
    12e4:	10 91 e0 00 	lds	r17, 0x00E0
    12e8:	20 91 e1 00 	lds	r18, 0x00E1
    12ec:	30 91 e2 00 	lds	r19, 0x00E2
    12f0:	40 91 e3 00 	lds	r20, 0x00E3
    12f4:	50 91 e4 00 	lds	r21, 0x00E4
    12f8:	60 91 e5 00 	lds	r22, 0x00E5
    12fc:	70 91 e6 00 	lds	r23, 0x00E6
    1300:	80 91 e7 00 	lds	r24, 0x00E7
    1304:	90 91 e8 00 	lds	r25, 0x00E8
    1308:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
    130c:	80 93 f2 00 	sts	0x00F2, r24
	  }
	  oneSec_Counter = ((temp_var - 48) * 10);
	  LCD_DisplayChar(temp_var);
	  LCD_Select_RowCol(0,15);
	  temp_var = 0 ;
	  while(temp_var == 0)
    1310:	88 23       	and	r24, r24
    1312:	31 f3       	breq	.-52     	; 0x12e0 <RealTime_ClK_OPERATE+0x5c8>
	  {
		  temp_var = keypad_Read(key);
	  }
	  oneSec_Counter =oneSec_Counter + (temp_var - 48);
    1314:	90 91 f1 00 	lds	r25, 0x00F1
    1318:	90 53       	subi	r25, 0x30	; 48
    131a:	98 0f       	add	r25, r24
    131c:	90 93 f1 00 	sts	0x00F1, r25
	  LCD_DisplayChar(temp_var);
    1320:	0e 94 4e 05 	call	0xa9c	; 0xa9c <LCD_DisplayChar>
	  LCD_Select_RowCol(1,0);
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	60 e0       	ldi	r22, 0x00	; 0
    1328:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	   temp_var = 0 ;
    132c:	10 92 f2 00 	sts	0x00F2, r1
	  LCD_DisplayString("Next press '*'");
    1330:	80 e9       	ldi	r24, 0x90	; 144
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
	  while(keypad_Read(key) != '*');
    1338:	00 91 df 00 	lds	r16, 0x00DF
    133c:	10 91 e0 00 	lds	r17, 0x00E0
    1340:	20 91 e1 00 	lds	r18, 0x00E1
    1344:	30 91 e2 00 	lds	r19, 0x00E2
    1348:	40 91 e3 00 	lds	r20, 0x00E3
    134c:	50 91 e4 00 	lds	r21, 0x00E4
    1350:	60 91 e5 00 	lds	r22, 0x00E5
    1354:	70 91 e6 00 	lds	r23, 0x00E6
    1358:	80 91 e7 00 	lds	r24, 0x00E7
    135c:	90 91 e8 00 	lds	r25, 0x00E8
    1360:	0e 94 13 04 	call	0x826	; 0x826 <keypad_Read>
    1364:	8a 32       	cpi	r24, 0x2A	; 42
    1366:	41 f7       	brne	.-48     	; 0x1338 <RealTime_ClK_OPERATE+0x620>
	  LCD_Clear();
    1368:	0e 94 4a 05 	call	0xa94	; 0xa94 <LCD_Clear>
	  LCD_DisplayString("to setup Clock");
    136c:	88 e6       	ldi	r24, 0x68	; 104
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
	  LCD_Select_RowCol(1,3);
    1374:	81 e0       	ldi	r24, 0x01	; 1
    1376:	63 e0       	ldi	r22, 0x03	; 3
    1378:	0e 94 9e 05 	call	0xb3c	; 0xb3c <LCD_Select_RowCol>
	  LCD_DisplayString("press '1'");
    137c:	87 e7       	ldi	r24, 0x77	; 119
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	0e 94 8f 05 	call	0xb1e	; 0xb1e <LCD_DisplayString>
  }
    1384:	cf 91       	pop	r28
    1386:	1f 91       	pop	r17
    1388:	0f 91       	pop	r16
    138a:	08 95       	ret

0000138c <__vector_10>:
  
  
  ISR(TIMER0_COMP_vect)
  {
    138c:	1f 92       	push	r1
    138e:	0f 92       	push	r0
    1390:	0f b6       	in	r0, 0x3f	; 63
    1392:	0f 92       	push	r0
    1394:	11 24       	eor	r1, r1
    1396:	8f 93       	push	r24
	  Five_msec = 1;
    1398:	81 e0       	ldi	r24, 0x01	; 1
    139a:	80 93 f0 00 	sts	0x00F0, r24
  }
    139e:	8f 91       	pop	r24
    13a0:	0f 90       	pop	r0
    13a2:	0f be       	out	0x3f, r0	; 63
    13a4:	0f 90       	pop	r0
    13a6:	1f 90       	pop	r1
    13a8:	18 95       	reti

000013aa <__vector_5>:
  
  ISR(TIMER2_OVF_vect)
  {
    13aa:	1f 92       	push	r1
    13ac:	0f 92       	push	r0
    13ae:	0f b6       	in	r0, 0x3f	; 63
    13b0:	0f 92       	push	r0
    13b2:	11 24       	eor	r1, r1
    13b4:	8f 93       	push	r24
	  oneSec_Counter++;
    13b6:	80 91 f1 00 	lds	r24, 0x00F1
    13ba:	8f 5f       	subi	r24, 0xFF	; 255
    13bc:	80 93 f1 00 	sts	0x00F1, r24
    13c0:	8f 91       	pop	r24
    13c2:	0f 90       	pop	r0
    13c4:	0f be       	out	0x3f, r0	; 63
    13c6:	0f 90       	pop	r0
    13c8:	1f 90       	pop	r1
    13ca:	18 95       	reti

000013cc <main>:


#include <avr/io.h>

int main(void)
{
    13cc:	ff cf       	rjmp	.-2      	; 0x13cc <main>

000013ce <__udivmodqi4>:
    13ce:	99 1b       	sub	r25, r25
    13d0:	79 e0       	ldi	r23, 0x09	; 9
    13d2:	04 c0       	rjmp	.+8      	; 0x13dc <__udivmodqi4_ep>

000013d4 <__udivmodqi4_loop>:
    13d4:	99 1f       	adc	r25, r25
    13d6:	96 17       	cp	r25, r22
    13d8:	08 f0       	brcs	.+2      	; 0x13dc <__udivmodqi4_ep>
    13da:	96 1b       	sub	r25, r22

000013dc <__udivmodqi4_ep>:
    13dc:	88 1f       	adc	r24, r24
    13de:	7a 95       	dec	r23
    13e0:	c9 f7       	brne	.-14     	; 0x13d4 <__udivmodqi4_loop>
    13e2:	80 95       	com	r24
    13e4:	08 95       	ret

000013e6 <utoa>:
    13e6:	fb 01       	movw	r30, r22
    13e8:	9f 01       	movw	r18, r30
    13ea:	42 30       	cpi	r20, 0x02	; 2
    13ec:	74 f0       	brlt	.+28     	; 0x140a <utoa+0x24>
    13ee:	45 32       	cpi	r20, 0x25	; 37
    13f0:	64 f4       	brge	.+24     	; 0x140a <utoa+0x24>
    13f2:	64 2f       	mov	r22, r20
    13f4:	77 27       	eor	r23, r23
    13f6:	0e 94 19 0a 	call	0x1432	; 0x1432 <__udivmodhi4>
    13fa:	80 5d       	subi	r24, 0xD0	; 208
    13fc:	8a 33       	cpi	r24, 0x3A	; 58
    13fe:	0c f0       	brlt	.+2      	; 0x1402 <utoa+0x1c>
    1400:	89 5d       	subi	r24, 0xD9	; 217
    1402:	81 93       	st	Z+, r24
    1404:	cb 01       	movw	r24, r22
    1406:	00 97       	sbiw	r24, 0x00	; 0
    1408:	a1 f7       	brne	.-24     	; 0x13f2 <utoa+0xc>
    140a:	10 82       	st	Z, r1
    140c:	c9 01       	movw	r24, r18
    140e:	0c 94 09 0a 	jmp	0x1412	; 0x1412 <strrev>

00001412 <strrev>:
    1412:	dc 01       	movw	r26, r24
    1414:	fc 01       	movw	r30, r24
    1416:	67 2f       	mov	r22, r23
    1418:	71 91       	ld	r23, Z+
    141a:	77 23       	and	r23, r23
    141c:	e1 f7       	brne	.-8      	; 0x1416 <strrev+0x4>
    141e:	32 97       	sbiw	r30, 0x02	; 2
    1420:	04 c0       	rjmp	.+8      	; 0x142a <strrev+0x18>
    1422:	7c 91       	ld	r23, X
    1424:	6d 93       	st	X+, r22
    1426:	70 83       	st	Z, r23
    1428:	62 91       	ld	r22, -Z
    142a:	ae 17       	cp	r26, r30
    142c:	bf 07       	cpc	r27, r31
    142e:	c8 f3       	brcs	.-14     	; 0x1422 <strrev+0x10>
    1430:	08 95       	ret

00001432 <__udivmodhi4>:
    1432:	aa 1b       	sub	r26, r26
    1434:	bb 1b       	sub	r27, r27
    1436:	51 e1       	ldi	r21, 0x11	; 17
    1438:	07 c0       	rjmp	.+14     	; 0x1448 <__udivmodhi4_ep>

0000143a <__udivmodhi4_loop>:
    143a:	aa 1f       	adc	r26, r26
    143c:	bb 1f       	adc	r27, r27
    143e:	a6 17       	cp	r26, r22
    1440:	b7 07       	cpc	r27, r23
    1442:	10 f0       	brcs	.+4      	; 0x1448 <__udivmodhi4_ep>
    1444:	a6 1b       	sub	r26, r22
    1446:	b7 0b       	sbc	r27, r23

00001448 <__udivmodhi4_ep>:
    1448:	88 1f       	adc	r24, r24
    144a:	99 1f       	adc	r25, r25
    144c:	5a 95       	dec	r21
    144e:	a9 f7       	brne	.-22     	; 0x143a <__udivmodhi4_loop>
    1450:	80 95       	com	r24
    1452:	90 95       	com	r25
    1454:	bc 01       	movw	r22, r24
    1456:	cd 01       	movw	r24, r26
    1458:	08 95       	ret

0000145a <_exit>:
    145a:	f8 94       	cli

0000145c <__stop_program>:
    145c:	ff cf       	rjmp	.-2      	; 0x145c <__stop_program>
